import recoil from 'recoil';
import react from 'react';
import transitJs from 'transit-js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function err(message) {
  const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the
  // err.stack property is accessed.

  if (error.stack === undefined) {
    // IE sets the stack only if error is thrown
    try {
      throw error;
    } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty

  }

  return error;
}

var err_1 = err;

// @oss-only


var Recoil_err = err_1;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Return a proxy object based on the provided base and factories objects.
 * The proxy will include all properties of the base object as-is.
 * The factories object contains callbacks to obtain the values of the properies
 * for its keys.
 *
 * This is useful for providing users an object where some properties may be
 * lazily computed only on first access.
 */
// $FlowIssue[unclear-type]

function lazyProxy(base, factories) {
  const proxy = new Proxy(base, {
    // Compute and cache lazy property if not already done.
    get: (target, prop) => {
      if (!(prop in target) && prop in factories) {
        target[prop] = factories[prop]();
      }

      return target[prop];
    },
    // This method allows user to iterate keys as normal
    ownKeys: target => {

      return Object.keys(target);
    }
  }); // $FlowIssue[incompatible-return]

  return proxy;
}

var Recoil_lazyProxy = lazyProxy;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const {
  DefaultValue,
  RecoilLoadable,
  useRecoilSnapshot,
  useRecoilStoreID,
  useRecoilTransaction_UNSTABLE
} = recoil;



const {
  useCallback,
  useEffect,
  useRef
} = react;





const DEFAULT_VALUE = new DefaultValue();

function setIntersectsMap(a, b) {
  if (a.size <= b.size) {
    for (const x of a) {
      if (b.has(x)) {
        return true;
      }
    }
  } else {
    for (const x of b.keys()) {
      if (a.has(x)) {
        return true;
      }
    }
  }

  return false;
}

class Registries {
  constructor() {
    _defineProperty(this, "atomRegistries", new Map());

    _defineProperty(this, "nextEffectKey", 0);

    _defineProperty(this, "storageRegistries", new Map());
  }

  getAtomRegistry(recoilStoreID, externalStoreKey // flowlint-next-line unclear-type:off
  ) {
    if (!this.atomRegistries.has(recoilStoreID)) {
      this.atomRegistries.set(recoilStoreID, new Map());
    }

    const storeRegistries = this.atomRegistries.get(recoilStoreID);
    const registry = storeRegistries === null || storeRegistries === void 0 ? void 0 : storeRegistries.get(externalStoreKey);

    if (registry != null) {
      return registry;
    }

    const newRegistry = new Map();
    storeRegistries === null || storeRegistries === void 0 ? void 0 : storeRegistries.set(externalStoreKey, newRegistry);
    return newRegistry;
  }

  setAtomEffect(recoilStoreID, externalStoreKey, node, options) {
    var _atomRegistry$get;

    const atomRegistry = this.getAtomRegistry(recoilStoreID, externalStoreKey);

    if (!atomRegistry.has(node.key)) {
      atomRegistry.set(node.key, {
        atom: node,
        effects: new Map()
      });
    }

    const effectKey = this.nextEffectKey++;
    const effectRegistration = {
      options,
      subscribedItemKeys: new Set([options.itemKey])
    };
    (_atomRegistry$get = atomRegistry.get(node.key)) === null || _atomRegistry$get === void 0 ? void 0 : _atomRegistry$get.effects.set(effectKey, effectRegistration);
    return {
      effectRegistration,
      unregisterEffect: () => {
        var _atomRegistry$get2;

        return void ((_atomRegistry$get2 = atomRegistry.get(node.key)) === null || _atomRegistry$get2 === void 0 ? void 0 : _atomRegistry$get2.effects.delete(effectKey));
      }
    };
  }

  getStorage(recoilStoreID, externalStoreKey) {
    var _this$storageRegistri;

    return (_this$storageRegistri = this.storageRegistries.get(recoilStoreID)) === null || _this$storageRegistri === void 0 ? void 0 : _this$storageRegistri.get(externalStoreKey);
  }

  setStorage(recoilStoreID, externalStoreKey, storage) {
    var _this$storageRegistri2;

    if (!this.storageRegistries.has(recoilStoreID)) {
      this.storageRegistries.set(recoilStoreID, new Map());
    }

    (_this$storageRegistri2 = this.storageRegistries.get(recoilStoreID)) === null || _this$storageRegistri2 === void 0 ? void 0 : _this$storageRegistri2.set(externalStoreKey, storage);
    return () => {
      var _this$storageRegistri3;

      return void ((_this$storageRegistri3 = this.storageRegistries.get(recoilStoreID)) === null || _this$storageRegistri3 === void 0 ? void 0 : _this$storageRegistri3.delete(externalStoreKey));
    };
  }

}

const registries = new Registries();

function validateLoadable(input, {
  refine,
  actionOnFailure_UNSTABLE
}) {
  return RecoilLoadable.of(input).map(x => {
    if (x instanceof DefaultValue) {
      return x;
    }

    const result = refine(x);

    if (result.type === 'success') {
      return result.value;
    }

    if (actionOnFailure_UNSTABLE === 'defaultValue') {
      return new DefaultValue();
    }

    throw Recoil_err(`[${result.path.toString()}]: ${result.message}`);
  });
}

function readAtomItems(effectRegistration, readFromStorage, diff) {
  const {
    options
  } = effectRegistration;
  const readFromStorageRequired = readFromStorage !== null && readFromStorage !== void 0 ? readFromStorage : itemKey => RecoilLoadable.error(`Read functionality not provided for ${options.storeKey != null ? `"${options.storeKey}" ` : ''}store in useRecoilSync() hook while updating item "${itemKey}".`);
  effectRegistration.subscribedItemKeys = new Set();

  const read = itemKey => {
    effectRegistration.subscribedItemKeys.add(itemKey);
    const value = diff !== null && diff !== void 0 && diff.has(itemKey) ? diff === null || diff === void 0 ? void 0 : diff.get(itemKey) : readFromStorageRequired(itemKey);

    if (RecoilLoadable.isLoadable(value)) {
      // $FlowIssue[incompatible-type]
      const loadable = value;

      if (loadable.state === 'hasError') {
        throw loadable.contents;
      }
    }

    return value;
  };

  let value;

  try {
    value = options.read({
      read
    });
  } catch (error) {
    return RecoilLoadable.error(error);
  }

  return value instanceof DefaultValue ? null : validateLoadable(value, options);
}

function writeAtomItemsToDiff(diff, options, readFromStorage, loadable) {
  if (loadable != null && (loadable === null || loadable === void 0 ? void 0 : loadable.state) !== 'hasValue') {
    return diff;
  }

  const readFromStorageRequired = readFromStorage !== null && readFromStorage !== void 0 ? readFromStorage : _ => {
    throw Recoil_err(`Read functionality not provided for ${options.storeKey != null ? `"${options.storeKey}" ` : ''}store in useRecoilSync() hook while writing item "${options.itemKey}".`);
  };

  const read = itemKey => diff.has(itemKey) ? diff.get(itemKey) : readFromStorageRequired(itemKey);

  const write = (k, l) => void diff.set(k, l);

  const reset = k => void diff.set(k, DEFAULT_VALUE);

  options.write({
    write,
    reset,
    read
  }, loadable == null ? DEFAULT_VALUE : loadable.contents);
  return diff;
}

const itemsFromSnapshot = (recoilStoreID, storeKey, getInfo) => {
  const items = new Map();

  for (const [, {
    atom,
    effects
  }] of registries.getAtomRegistry(recoilStoreID, storeKey)) {
    for (const [, {
      options
    }] of effects) {
      var _registries$getStorag;

      const atomInfo = getInfo(atom);
      writeAtomItemsToDiff(items, options, (_registries$getStorag = registries.getStorage(recoilStoreID, storeKey)) === null || _registries$getStorag === void 0 ? void 0 : _registries$getStorag.read, atomInfo.isSet || options.syncDefault === true ? atomInfo.loadable : null);
    }
  }

  return items;
};

function getWriteInterface(recoilStoreID, storeKey, diff, getInfo) {
  // Use a Proxy so we only generate `allItems` if it's actually used.
  return Recoil_lazyProxy({
    diff
  }, {
    allItems: () => itemsFromSnapshot(recoilStoreID, storeKey, getInfo)
  });
} ///////////////////////
// useRecoilSync()
///////////////////////


function useRecoilSync({
  storeKey,
  write,
  read,
  listen
}) {
  const recoilStoreID = useRecoilStoreID(); // Subscribe to Recoil state changes

  const snapshot = useRecoilSnapshot();
  const previousSnapshotRef = useRef(snapshot);
  useEffect(() => {
    if (write != null && snapshot !== previousSnapshotRef.current) {
      previousSnapshotRef.current = snapshot;
      const diff = new Map();
      const atomRegistry = registries.getAtomRegistry(recoilStoreID, storeKey);
      const modifiedAtoms = snapshot.getNodes_UNSTABLE({
        isModified: true
      });

      for (const atom of modifiedAtoms) {
        const registration = atomRegistry.get(atom.key);

        if (registration != null) {
          var _atomInfo$loadable, _registration$pending, _registration$pending2;

          const atomInfo = snapshot.getInfo_UNSTABLE(registration.atom); // Avoid feedback loops:
          // Don't write to storage updates that came from listening to storage

          if (atomInfo.isSet && ((_atomInfo$loadable = atomInfo.loadable) === null || _atomInfo$loadable === void 0 ? void 0 : _atomInfo$loadable.contents) !== ((_registration$pending = registration.pendingUpdate) === null || _registration$pending === void 0 ? void 0 : _registration$pending.value) || !atomInfo.isSet && !(((_registration$pending2 = registration.pendingUpdate) === null || _registration$pending2 === void 0 ? void 0 : _registration$pending2.value) instanceof DefaultValue)) {
            for (const [, {
              options
            }] of registration.effects) {
              writeAtomItemsToDiff(diff, options, read, atomInfo.isSet || options.syncDefault === true ? atomInfo.loadable : null);
            }
          }

          delete registration.pendingUpdate;
        }
      }

      if (diff.size) {
        write(getWriteInterface(recoilStoreID, storeKey, diff, snapshot.getInfo_UNSTABLE));
      }
    }
  }, [read, recoilStoreID, snapshot, storeKey, write]);
  const updateItems = useRecoilTransaction_UNSTABLE(({
    set,
    reset
  }) => diff => {
    const atomRegistry = registries.getAtomRegistry(recoilStoreID, storeKey); // TODO iterating over all atoms registered with the store could be
    // optimized if we maintain a reverse look-up map of subscriptions.

    for (const [, atomRegistration] of atomRegistry) {
      // Iterate through the effects for this storage in reverse order as
      // the last effect takes priority.
      for (const [, effectRegistration] of Array.from(atomRegistration.effects).reverse()) {
        const {
          options,
          subscribedItemKeys
        } = effectRegistration; // Only consider updating this atom if it subscribes to any items
        // specified in the diff.

        if (setIntersectsMap(subscribedItemKeys, diff)) {
          const loadable = readAtomItems(effectRegistration, read, diff);

          if (loadable != null) {
            switch (loadable.state) {
              case 'hasValue':
                if (loadable.contents instanceof DefaultValue) {
                  atomRegistration.pendingUpdate = {
                    value: DEFAULT_VALUE
                  };
                  reset(atomRegistration.atom);
                } else {
                  atomRegistration.pendingUpdate = {
                    value: loadable.contents
                  };
                  set(atomRegistration.atom, loadable.contents);
                }

                break;

              case 'hasError':
                if (options.actionOnFailure_UNSTABLE === 'errorState') {
                  // TODO Async atom support to allow setting atom to error state
                  // in the meantime we can just reset it to default value...
                  atomRegistration.pendingUpdate = {
                    value: DEFAULT_VALUE
                  };
                  reset(atomRegistration.atom);
                }

                break;

              case 'loading':
                // TODO Async atom support
                throw Recoil_err('Recoil does not yet support setting atoms to an asynchronous state');
            } // If this effect set the atom, don't bother with lower-priority
            // effects. But, if the item didn't have a value then reset
            // below but ontinue falling back on other effects for the same
            // storage.  This can happen if multiple effects are used to
            // migrate to a new itemKey and we want to read from the
            // older key as a fallback.


            break;
          } else {
            atomRegistration.pendingUpdate = {
              value: DEFAULT_VALUE
            };
            reset(atomRegistration.atom);
          }
        }
      }
    }
  }, [recoilStoreID, storeKey, read]);
  const updateItem = useCallback((itemKey, newValue) => {
    updateItems(new Map([[itemKey, newValue]]));
  }, [updateItems]);
  const updateAllKnownItems = useCallback(itemSnapshot => {
    // Reset the value of any items that are registered and not included in
    // the user-provided snapshot.
    const atomRegistry = registries.getAtomRegistry(recoilStoreID, storeKey);

    for (const [, registration] of atomRegistry) {
      for (const [, {
        subscribedItemKeys
      }] of registration.effects) {
        for (const itemKey of subscribedItemKeys) {
          if (!itemSnapshot.has(itemKey)) {
            itemSnapshot.set(itemKey, DEFAULT_VALUE);
          }
        }
      }
    }

    updateItems(itemSnapshot);
  }, [recoilStoreID, storeKey, updateItems]);
  useEffect(() => // TODO try/catch errors and set atom to error state if actionOnFailure is errorState
  listen === null || listen === void 0 ? void 0 : listen({
    updateItem,
    updateItems,
    updateAllKnownItems
  }), [updateItem, updateItems, updateAllKnownItems, listen]); // Register Storage
  // Save before effects so that we can initialize atoms for initial render

  registries.setStorage(recoilStoreID, storeKey, {
    write,
    read
  });
  useEffect(() => registries.setStorage(recoilStoreID, storeKey, {
    write,
    read
  }), [recoilStoreID, storeKey, read, write]);
}

function RecoilSync({
  children,
  ...props
}) {
  useRecoilSync(props);
  return children;
} ///////////////////////
// syncEffect()
///////////////////////


function syncEffect(opt) {
  return ({
    node,
    trigger,
    storeID,
    setSelf,
    getLoadable,
    getInfo_UNSTABLE
  }) => {
    var _opt$itemKey;

    // Get options with defaults
    const itemKey = (_opt$itemKey = opt.itemKey) !== null && _opt$itemKey !== void 0 ? _opt$itemKey : node.key;
    const options = {
      itemKey,
      read: ({
        read
      }) => read(itemKey),
      write: ({
        write
      }, loadable) => write(itemKey, loadable),
      syncDefault: false,
      actionOnFailure_UNSTABLE: 'errorState',
      ...opt
    };
    const {
      storeKey
    } = options;
    const storage = registries.getStorage(storeID, storeKey); // Register Atom

    const {
      effectRegistration,
      unregisterEffect
    } = registries.setAtomEffect(storeID, storeKey, node, options);

    if (trigger === 'get') {
      // Initialize Atom value
      const readFromStorage = storage === null || storage === void 0 ? void 0 : storage.read;

      if (readFromStorage != null) {
        try {
          const loadable = readAtomItems(effectRegistration, readFromStorage);

          if (loadable != null) {
            switch (loadable.state) {
              case 'hasValue':
                if (!(loadable.contents instanceof DefaultValue)) {
                  setSelf(loadable.contents);
                }

                break;

              case 'hasError':
                if (options.actionOnFailure_UNSTABLE === 'errorState') {
                  throw loadable.contents;
                }

                break;

              case 'loading':
                setSelf(loadable.toPromise());
                break;
            }
          }
        } catch (error) {
          if (options.actionOnFailure_UNSTABLE === 'errorState') {
            throw error;
          }
        }
      } // Persist on Initial Read


      const writeToStorage = storage === null || storage === void 0 ? void 0 : storage.write;

      if (options.syncDefault === true && writeToStorage != null) {
        window.setTimeout(() => {
          const loadable = getLoadable(node);

          if (loadable.state === 'hasValue') {
            const diff = writeAtomItemsToDiff(new Map(), options, storage === null || storage === void 0 ? void 0 : storage.read, loadable);
            writeToStorage(getWriteInterface(storeID, storeKey, diff, getInfo_UNSTABLE));
          }
        }, 0);
      }
    } // Cleanup atom effect registration


    return unregisterEffect;
  };
}

var RecoilSync_1 = {
  useRecoilSync,
  RecoilSync,
  syncEffect,
  registries_FOR_TESTING: registries
};

var RecoilSync_2 = RecoilSync_1.useRecoilSync;
var RecoilSync_3 = RecoilSync_1.RecoilSync;
var RecoilSync_4 = RecoilSync_1.syncEffect;
var RecoilSync_5 = RecoilSync_1.registries_FOR_TESTING;

var RecoilSync$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  useRecoilSync: RecoilSync_2,
  RecoilSync: RecoilSync_3,
  syncEffect: RecoilSync_4,
  registries_FOR_TESTING: RecoilSync_5
});

/**
 * function to assert that a given value matches a checker
 */


/**
 * helper for raising an error based on a failure
 */
function raiseError(suffix, resultFailure) {
  if (resultFailure != null) {
    const path = resultFailure.path.toString();
    const message = resultFailure.message;
    throw Recoil_err(`[refine.js (path=${path}, message=${message})]: ${suffix}`);
  }

  throw Recoil_err(`[refine.js (null result)]: ${suffix}`);
}
/**
 * create a function to assert a value matches a checker, throwing otherwise
 *
 * For example,
 *
 * ```
 * const assert = assertion(array(number()));
 * const value: Array<number> = assert([1,2]);
 *
 * try {
 *   // should throw with `Refine.js assertion failed: ...`
 *   const invalid = assert('test');
 * } catch {
 * }
 * ```
 */


function assertion(checker, errorMessage = 'assertion error') {
  return value => {
    const result = checker(value);
    return result.type === 'success' ? result.value : raiseError(errorMessage, result);
  };
}
/**
 * create a CoercionFunction given a checker.
 *
 * Allows for null-coercing a value to a given type using a checker. Optionally
 * provide a callback which receives the full check
 * result object (e.g. for logging).
 *
 * Example:
 *
 * ```javascript
 * import {coercion, record, string} from 'refine';
 * import MyLogger from './MyLogger';
 *
 * const Person = record({
 *   name: string(),
 *   hobby: string(),
 * });
 *
 * const coerce = coercion(Person, result => MyLogger.log(result));
 *
 * declare value: mixed;
 *
 * // ?Person
 * const person = coerce(value);
 * ```
 */


function coercion(checker, onResult) {
  return value => {
    const result = checker(value);

    if (onResult != null) {
      onResult(result);
    }

    return result.type === 'success' ? result.value : null;
  };
}

var Refine_API = {
  assertion,
  coercion
};

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * refine: type-refinement combinator library for checking mixed values
 * see wiki for more info: https://fburl.com/wiki/14q16qqy
 *
 * 
 * @format
 * @oncall monitoring_interfaces
 */

/**
 * the result of successfully matching a value to its expected type
 */

/**
 * the result of checking whether a type matches an expected value
 */

/**
 * a function which checks if a given mixed value matches a type V,
 * returning the value if it does, otherwise a failure message.
 */

/**
 * utility type to extract flowtype matching checker structure
 *
 * ```
 * const check = array(record({a: number()}));
 *
 * // equal to: type MyArray = $ReadOnlyArray<{a: number}>;
 * type MyArray = CheckerReturnType<typeof check>;
 * ```
 */

/**
 * Path during checker traversal
 */
class Path {
  constructor(parent = null, field = '<root>') {
    _defineProperty(this, "parent", void 0);

    _defineProperty(this, "field", void 0);

    this.parent = parent;
    this.field = field;
  } // Method to extend path by a field while traversing a container


  extend(field) {
    return new Path(this, field);
  }

  toString() {
    const pieces = [];
    let current = this;

    while (current != null) {
      const {
        field,
        parent
      } = current;
      pieces.push(field);
      current = parent;
    }

    return pieces.reverse().join('');
  }

}
/**
 * wrap value in an object signifying successful checking
 */


function success(value, warnings) {
  return {
    type: 'success',
    value,
    warnings
  };
}
/**
 * indicate typecheck failed
 */


function failure(message, path) {
  return {
    type: 'failure',
    message,
    path
  };
}
/**
 * utility function for composing checkers
 */


function compose(checker, next) {
  return (value, path = new Path()) => {
    const result = checker(value, path);
    return result.type === 'failure' ? result : next(result, path);
  };
}

var Refine_Checkers = {
  Path,
  success,
  failure,
  compose
};

var Refine_Checkers_1 = Refine_Checkers.Path;
var Refine_Checkers_2 = Refine_Checkers.success;
var Refine_Checkers_3 = Refine_Checkers.failure;
var Refine_Checkers_4 = Refine_Checkers.compose;

var Refine_Checkers$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Path: Refine_Checkers_1,
  success: Refine_Checkers_2,
  failure: Refine_Checkers_3,
  compose: Refine_Checkers_4
});

const {
  Path: Path$1,
  compose: compose$1,
  failure: failure$1,
  success: success$1
} = Refine_Checkers$1; // Check that the provided value is a plain object and not an instance of some
// other container type, built-in, or user class.


function isPlainObject(value) {
  // $FlowIssue[method-unbinding]
  if (Object.prototype.toString.call(value) !== '[object Object]') {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}
/**
 * checker to assert if a mixed value is an array of
 * values determined by a provided checker
 */


function array(valueChecker) {
  return (value, path = new Path$1()) => {
    if (!Array.isArray(value)) {
      return failure$1('value is not an array', path);
    }

    const len = value.length;
    const out = new Array(len);
    const warnings = [];

    for (let i = 0; i < len; i++) {
      const element = value[i];
      const result = valueChecker(element, path.extend(`[${i}]`));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out[i] = result.value;

      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
}
/**
 * checker to assert if a mixed value is a tuple of values
 * determined by provided checkers. Extra entries are ignored.
 *
 * Example:
 * ```jsx
 * const checker = tuple( number(), string() );
 * ```
 *
 * Example with optional trailing entry:
 * ```jsx
 * const checker = tuple( number(), voidable(string()));
 * ```
 */


function tuple(...checkers) {
  return (value, path = new Path$1()) => {
    if (!Array.isArray(value)) {
      return failure$1('value is not an array', path);
    }

    const out = new Array(checkers.length);
    const warnings = [];

    for (const [i, checker] of checkers.entries()) {
      const result = checker(value[i], path.extend(`[${i}]`));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out[i] = result.value;

      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
}
/**
 * checker to assert if a mixed value is a string-keyed dict of
 * values determined by a provided checker
 */


function dict(valueChecker) {
  return (value, path = new Path$1()) => {
    if (typeof value !== 'object' || value === null || !isPlainObject(value)) {
      return failure$1('value is not an object', path);
    }

    const out = {};
    const warnings = [];

    for (const [key, element] of Object.entries(value)) {
      const result = valueChecker(element, path.extend(`.${key}`));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out[key] = result.value;

      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
} // expose opaque version of optional property as public api,
// forcing consistent usage of built-in `optional` to define optional properties


// not a public api, don't export at root
class OptionalProperty {
  constructor(checker) {
    _defineProperty(this, "checker", void 0);

    this.checker = checker;
  }

}
/**
 * checker which can only be used with `object` or `writablObject`. Marks a
 * field as optional, skipping the key in the result if it doesn't
 * exist in the input.
 *
 * @example
 * ```jsx
 * import {object, string, optional} from 'refine';
 *
 * const checker = object({a: string(), b: optional(string())});
 * assert(checker({a: 1}).type === 'success');
 * ```
 */


function optional(checker) {
  return new OptionalProperty((value, path = new Path$1()) => {
    const result = checker(value, path);

    if (result.type === 'failure') {
      return { ...result,
        message: '(optional property) ' + result.message
      };
    } else {
      return result;
    }
  });
}
/**
 * checker to assert if a mixed value is a fixed-property object,
 * with key-value pairs determined by a provided object of checkers.
 * Any extra properties in the input object values are ignored.
 * Class instances are not supported, use the custom() checker for those.
 *
 * Example:
 * ```jsx
 * const myObject = object({
 *   name: string(),
 *   job: object({
 *     years: number(),
 *     title: string(),
 *   }),
 * });
 * ```
 *
 * Properties can be optional using `voidable()` or have default values
 * using `withDefault()`:
 * ```jsx
 * const customer = object({
 *   name: string(),
 *   reference: voidable(string()),
 *   method: withDefault(string(), 'email'),
 * });
 * ```
 */


function object(checkers) {
  const checkerProperties = Object.keys(checkers);
  return (value, path = new Path$1()) => {
    if (typeof value !== 'object' || value === null || !isPlainObject(value)) {
      return failure$1('value is not an object', path);
    }

    const out = {};
    const warnings = [];

    for (const key of checkerProperties) {
      const provided = checkers[key];
      let check;
      let element;

      if (provided instanceof OptionalProperty) {
        check = provided.checker;

        if (!value.hasOwnProperty(key)) {
          continue;
        }

        element = value[key];
      } else {
        check = provided;
        element = value.hasOwnProperty(key) ? value[key] : undefined;
      }

      const result = check(element, path.extend(`.${key}`));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out[key] = result.value;

      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
}
/**
 * checker to assert if a mixed value is a Set type
 */


function set(checker) {
  return (value, path = new Path$1()) => {
    if (!(value instanceof Set)) {
      return failure$1('value is not a Set', path);
    }

    const out = new Set();
    const warnings = [];

    for (const item of value) {
      const result = checker(item, path.extend('[]'));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out.add(result.value);

      if (result.warnings.length) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
}
/**
 * checker to assert if a mixed value is a Map.
 */


function map(keyChecker, valueChecker) {
  return (value, path = new Path$1()) => {
    if (!(value instanceof Map)) {
      return failure$1('value is not a Map', path);
    }

    const out = new Map();
    const warnings = [];

    for (const [k, v] of value.entries()) {
      const keyResult = keyChecker(k, path.extend(`[${k}] key`));

      if (keyResult.type === 'failure') {
        return failure$1(keyResult.message, keyResult.path);
      }

      const valueResult = valueChecker(v, path.extend(`[${k}]`));

      if (valueResult.type === 'failure') {
        return failure$1(valueResult.message, valueResult.path);
      }

      out.set(k, v);
      warnings.push(...keyResult.warnings, ...valueResult.warnings);
    }

    return success$1(out, warnings);
  };
}
/**
 * identical to `array()` except the resulting value is a writable flow type.
 */


function writableArray(valueChecker) {
  return compose$1(array(valueChecker), ({
    value,
    warnings
  }) => success$1([...value], warnings));
}
/**
 * identical to `dict()` except the resulting value is a writable flow type.
 */


function writableDict(valueChecker) {
  return compose$1(dict(valueChecker), ({
    value,
    warnings
  }) => success$1({ ...value
  }, warnings));
}
/**
 * identical to `object()` except the resulting value is a writable flow type.
 */


function writableObject(checkers) {
  return compose$1(object(checkers), ({
    value,
    warnings
  }) => success$1({ ...value
  }, warnings));
}

var Refine_ContainerCheckers = {
  array,
  tuple,
  object,
  optional,
  dict,
  set,
  map,
  writableArray,
  writableDict,
  writableObject
};

var Refine_ContainerCheckers_1 = Refine_ContainerCheckers.array;
var Refine_ContainerCheckers_2 = Refine_ContainerCheckers.tuple;
var Refine_ContainerCheckers_3 = Refine_ContainerCheckers.object;
var Refine_ContainerCheckers_4 = Refine_ContainerCheckers.optional;
var Refine_ContainerCheckers_5 = Refine_ContainerCheckers.dict;
var Refine_ContainerCheckers_6 = Refine_ContainerCheckers.set;
var Refine_ContainerCheckers_7 = Refine_ContainerCheckers.map;
var Refine_ContainerCheckers_8 = Refine_ContainerCheckers.writableArray;
var Refine_ContainerCheckers_9 = Refine_ContainerCheckers.writableDict;
var Refine_ContainerCheckers_10 = Refine_ContainerCheckers.writableObject;

var Refine_ContainerCheckers$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  array: Refine_ContainerCheckers_1,
  tuple: Refine_ContainerCheckers_2,
  object: Refine_ContainerCheckers_3,
  optional: Refine_ContainerCheckers_4,
  dict: Refine_ContainerCheckers_5,
  set: Refine_ContainerCheckers_6,
  map: Refine_ContainerCheckers_7,
  writableArray: Refine_ContainerCheckers_8,
  writableDict: Refine_ContainerCheckers_9,
  writableObject: Refine_ContainerCheckers_10
});

const {
  assertion: assertion$1
} = Refine_API;
/**
 * function which takes a json string, parses it,
 * and matches it with a checker (returning null if no match)
 */


/**
 * @param text A valid JSON string or null.
 * @param reviver A function that transforms the results. This function is called for each member of the object.
 * If a member contains nested objects, the nested objects are transformed before the parent object is.
 */
function tryParseJSONMixed(text, reviver) {
  if (text == null) {
    return null;
  }

  try {
    return JSON.parse(text, reviver);
  } catch {
    return null;
  }
}
/**
 * creates a JSON parser which will error if the resulting value is invalid
 */


function jsonParserEnforced(checker, suffix) {
  const assertedChecker = assertion$1(checker, suffix !== null && suffix !== void 0 ? suffix : 'value is invalid');
  return rawJSON => {
    return assertedChecker(tryParseJSONMixed(rawJSON !== null && rawJSON !== void 0 ? rawJSON : ''));
  };
}
/**
 * convienience function to wrap a checker in a function
 * for easy JSON string parsing.
 */


function jsonParser(checker) {
  return rawJSON => {
    const result = checker(tryParseJSONMixed(rawJSON));
    return result.type === 'success' ? result.value : null;
  };
}

var Refine_JSON = {
  jsonParserEnforced,
  jsonParser
};

const {
  Path: Path$2,
  compose: compose$2,
  failure: failure$2,
  success: success$2
} = Refine_Checkers$1;
/**
 * a mixed (i.e. untyped) value
 */


function mixed() {
  return MIXED_CHECKER;
}

const MIXED_CHECKER = value => success$2(value, []);
/**
 * checker to assert if a mixed value matches a literal value
 */


function literal(literalValue) {
  const str = value => JSON.stringify(value);

  return (value, path = new Path$2()) => {
    var _str;

    return value === literalValue ? success$2(literalValue, []) : failure$2(`value is not literal ${(_str = str(literalValue)) !== null && _str !== void 0 ? _str : 'void'}`, path);
  };
}
/**
 * boolean value checker
 */


function bool() {
  // NOTE boolean is a reserved word so boolean() will not export properly in OSS
  return (value, path = new Path$2()) => typeof value === 'boolean' ? success$2(value, []) : failure$2('value is not a boolean', path);
}
/**
 * checker to assert if a mixed value is a number
 */


function number() {
  return (value, path = new Path$2()) => typeof value === 'number' ? success$2(value, []) : failure$2('value is not a number', path);
}
/**
 * Checker to assert if a mixed value is a string.
 *
 * Provide an optional RegExp template to match string against.
 */


function string(regex) {
  return (value, path = new Path$2()) => {
    if (typeof value !== 'string') {
      return failure$2('value is not a string', path);
    }

    if (regex != null && !regex.test(value)) {
      return failure$2(`value does not match regex: ${regex.toString()}`, path);
    }

    return success$2(value, []);
  };
}
/**
 * Checker to assert if a mixed value matches a union of string literals.
 * Legal values are provided as key/values in an object and may be translated by
 * providing different values in the object.
 *
 * For example:
 * ```jsx
 * const suitChecker = stringLiterals({
 *   heart: 'heart',
 *   spade: 'spade',
 *   club: 'club',
 *   diamond: 'diamond',
 * });
 *
 * const suit: 'heart' | 'spade' | 'club' | 'diamond' = assertion(suitChecker())(x);
 * ```
 *
 * Strings can also be mapped to new values:
 * ```jsx
 * const placeholderChecker = stringLiterals({
 *   foo: 'spam',
 *   bar: 'eggs',
 * });
 * ```
 *
 * It can be useful to have a single source of truth for your literals.  To
 * only specify them once and use it for both the Flow union type and the
 * runtime checker you can use the following pattern:
 * ```jsx
 * const suits = {
 *   heart: 'heart',
 *   spade: 'spade',
 *   club: 'club',
 *   diamond: 'diamond',
 * };
 * type Suit = $Values<typeof suits>;
 * const suitChecker = stringLiterls(suits);
 * ```
 */


function stringLiterals(enumValues) {
  return (value, path = new Path$2()) => {
    if (typeof value !== 'string') {
      return failure$2('value must be a string', path);
    }

    const out = enumValues[value];

    if (out == null) {
      return failure$2(`value is not one of ${Object.keys(enumValues).join(', ')}`, path);
    }

    return success$2(out, []);
  };
}
/*
 * Checker to assert if a mixed value matches a string | number value of an
 * object. This is useful for non Flow enums, in the form of {[string]: string}
 * or {[string]: number}.
 *
 * For example:
 * ```jsx
 * const MyEnum = {foo: 'bar', baz: 'bat'};
 * const enumObjectChecker = enumObject(MyEnum);
 * const value: 'bar' | 'bat' = assertion(enumObjectChecker())(x);
 * ```
 */


function enumObject(enumObj) {
  const enumValues = Object.keys(enumObj).reduce((res, key) => Object.assign(res, {
    [enumObj[key]]: enumObj[key]
  }), {});
  const stringLiteralsChecker = stringLiterals(enumValues);
  return (rawValue, path = new Path$2()) => {
    const value = typeof rawValue === 'number' ? rawValue.toString() : rawValue;
    const result = stringLiteralsChecker(value, path);

    if (result.type === 'success' && typeof result.value !== typeof rawValue) {
      return failure$2('input must be the same type as the enum values', path);
    }

    return result;
  };
}
/**
 * checker to assert if a mixed value is a Date object
 *
 * For example:
 * ```jsx
 * const dateChecker = date();
 *
 * assertion(dateChecker())(new Date());
 * ```
 */


function date() {
  return (value, path = new Path$2()) => {
    if (!(value instanceof Date)) {
      return failure$2('value is not a date', path);
    }

    if (isNaN(value)) {
      return failure$2('invalid date', path);
    }

    return success$2(value, []);
  };
}
/**
 * checker to coerce a date string to a Date object.  This is useful for input
 * that was from a JSON encoded `Date` object.
 *
 * For example:
 * ```jsx
 * const jsonDateChecker = coerce(jsonDate({encoding: 'string'}));
 *
 * jsonDateChecker('October 26, 1985');
 * jsonDateChecker('1955-11-05T07:00:00.000Z');
 * jsonDateChecker(JSON.stringify(new Date()));
 * ```
 */


function jsonDate() {
  return compose$2(string(), ({
    value,
    warnings
  }, path) => {
    const parsedDate = new Date(value);
    return Number.isNaN(parsedDate) ? failure$2('value is not valid date string', path) : success$2(parsedDate, warnings);
  });
}

var Refine_PrimitiveCheckers = {
  mixed,
  literal,
  bool,
  number,
  string,
  stringLiterals,
  date,
  jsonDate,
  enumObject
};

const {
  Path: Path$3,
  compose: compose$3,
  failure: failure$3,
  success: success$3
} = Refine_Checkers$1;
/**
 * Cast the type of a value after passing a given checker
 *
 * For example:
 *
 * ```javascript
 * import {string, asType} from 'refine';
 *
 * opaque type ID = string;
 *
 * const IDChecker: Checker<ID> = asType(string(), s => (s: ID));
 * ```
 */


function asType(checker, cast) {
  return compose$3(checker, ({
    value,
    warnings
  }) => success$3(cast(value), warnings));
}

function unionFailure(message, path, failures) {
  return failure$3(`${message}: ${failures.map(f => f.message).join(', ')}`, path);
}
/**
 * checker which asserts the value matches
 * at least one of the two provided checkers
 */


function or(aChecker, bChecker) {
  return (value, path = new Path$3()) => {
    const a = aChecker(value, path);

    if (a.type === 'success') {
      return success$3(a.value, a.warnings);
    }

    const b = bChecker(value, path);

    if (b.type === 'success') {
      return success$3(b.value, b.warnings);
    }

    return unionFailure('value did not match any types in or()', path, [a, b]);
  };
}
/**
 * checker which asserts the value matches
 * at least one of the provided checkers
 *
 * NOTE: the reason `union` and `or` both exist is that there is a bug
 *       within flow that prevents extracting the type from `union` without
 *       annotation -- see https://fburl.com/gz7u6401
 */


function union(...checkers) {
  return (value, path = new Path$3()) => {
    const failures = [];

    for (const checker of checkers) {
      const result = checker(value, path);

      if (result.type === 'success') {
        return success$3(result.value, result.warnings);
      }

      failures.push(result);
    }

    return unionFailure('value did not match any types in union', path, failures);
  };
}
/**
 * Provide a set of checkers to check in sequence to use the first match.
 * This is similar to union(), but all checkers must have the same type.
 *
 * This can be helpful for supporting backward compatibility.  For example the
 * following loads a string type, but can also convert from a number as the
 * previous version or pull from an object as an even older version:
 *
 * ```jsx
 * const backwardCompatibilityChecker: Checker<string> = match(
 *   string(),
 *   asType(number(), num => `${num}`),
 *   asType(object({num: number()}), obj => `${obj.num}`),
 * );
 * ```
 */


function match(...checkers) {
  return union(...checkers);
}
/**
 * wraps a given checker, making the valid value nullable
 *
 * By default, a value passed to nullable must match the checker spec exactly
 * when it is not null, or it will fail.
 *
 * passing the `nullWithWarningWhenInvalid` enables gracefully handling invalid
 * values that are less important -- if the provided checker is invalid,
 * the new checker will return null.
 *
 * For example:
 *
 * ```javascript
 * import {nullable, record, string} from 'refine';
 *
 * const Options = object({
 *   // this must be a non-null string,
 *   // or Options is not valid
 *   filename: string(),
 *
 *   // if this field is not a string,
 *   // it will be null and Options will pass the checker
 *   description: nullable(string(), {
 *     nullWithWarningWhenInvalid: true,
 *   })
 * })
 *
 * const result = Options({filename: 'test', description: 1});
 *
 * invariant(result.type === 'success');
 * invariant(result.value.description === null);
 * invariant(result.warnings.length === 1); // there will be a warning
 * ```
 */


function nullable(checker, options) {
  const {
    nullWithWarningWhenInvalid = false
  } = options !== null && options !== void 0 ? options : {};
  return (value, parentPath = new Path$3()) => {
    if (value == null) {
      return success$3(value, []);
    }

    const result = checker(value, parentPath);

    if (result.type === 'success') {
      return success$3(result.value, result.warnings);
    } // if this is enabled, "succeed" the checker with a warning
    // if the non-null value does not match expectation


    if (nullWithWarningWhenInvalid) {
      return success$3(null, [result]);
    }

    const {
      message,
      path
    } = result;
    return failure$3(message, path);
  };
}
/**
 * wraps a given checker, making the valid value voidable
 *
 * By default, a value passed to voidable must match the checker spec exactly
 * when it is not undefined, or it will fail.
 *
 * passing the `undefinedWithWarningWhenInvalid` enables gracefully handling invalid
 * values that are less important -- if the provided checker is invalid,
 * the new checker will return undefined.
 *
 * For example:
 *
 * ```javascript
 * import {voidable, record, string} from 'refine';
 *
 * const Options = object({
 *   // this must be a string, or Options is not valid
 *   filename: string(),
 *
 *   // this must be a string or undefined,
 *   // or Options is not valid
 *   displayName: voidable(string()),
 *
 *   // if this field is not a string,
 *   // it will be undefined and Options will pass the checker
 *   description: voidable(string(), {
 *     undefinedWithWarningWhenInvalid: true,
 *   })
 * })
 *
 * const result = Options({filename: 'test', description: 1});
 *
 * invariant(result.type === 'success');
 * invariant(result.value.description === undefined);
 * invariant(result.warnings.length === 1); // there will be a warning
 * ```
 */


function voidable(checker, options) {
  const {
    undefinedWithWarningWhenInvalid = false
  } = options !== null && options !== void 0 ? options : {};
  return (value, parentPath = new Path$3()) => {
    if (value === undefined) {
      return success$3(undefined, []);
    }

    const result = checker(value, parentPath);

    if (result.type === 'success') {
      return success$3(result.value, result.warnings);
    } // if this is enabled, "succeed" the checker with a warning
    // if the non-void value does not match expectation


    if (undefinedWithWarningWhenInvalid) {
      return success$3(undefined, [result]);
    }

    const {
      message,
      path
    } = result;
    return failure$3(message, path);
  };
}
/**
 * a checker that provides a withDefault value if the provided value is nullable.
 *
 * For example:
 * ```jsx
 * const objPropertyWithDefault = object({
 *   foo: withDefault(number(), 123),
 * });
 * ```
 * Both `{}` and `{num: 123}` will refine to `{num: 123}`
 */


function withDefault(checker, fallback) {
  return (value, path = new Path$3()) => {
    if (value == null) {
      return success$3(fallback, []);
    }

    const result = checker(value, path);
    return result.type === 'failure' || result.value != null ? result : success$3(fallback, []);
  };
}
/**
 * wraps a checker with a logical constraint.
 *
 * Predicate function can return either a boolean result or
 * a tuple with a result and message
 *
 * For example:
 *
 * ```javascript
 * import {number, constraint} from 'refine';
 *
 * const evenNumber = constraint(
 *   number(),
 *   n => n % 2 === 0
 * );
 *
 * const passes = evenNumber(2);
 * // passes.type === 'success';
 *
 * const fails = evenNumber(1);
 * // fails.type === 'failure';
 * ```
 */


function constraint(checker, predicate) {
  return compose$3(checker, ({
    value,
    warnings
  }, path) => {
    const result = predicate(value);
    const [passed, message] = typeof result === 'boolean' ? [result, 'value failed constraint check'] : result;
    return passed ? success$3(value, warnings) : failure$3(message, path);
  });
}
/**
 * wrapper to allow for passing a lazy checker value. This enables
 * recursive types by allowing for passing in the returned value of
 * another checker. For example:
 *
 * ```javascript
 * const user = object({
 *   id: number(),
 *   name: string(),
 *   friends: array(lazy(() => user))
 * });
 * ```
 *
 * Example of array with arbitrary nesting depth:
 * ```jsx
 * const entry = or(number(), array(lazy(() => entry)));
 * const nestedArray = array(entry);
 * ```
 */


function lazy(getChecker) {
  return (value, path = new Path$3()) => {
    const checker = getChecker();
    return checker(value, path);
  };
}
/**
 * helper to create a custom checker from a provided function.
 * If the function returns a non-nullable value, the checker succeeds.
 *
 * ```jsx
 * const myClassChecker = custom(x => x instanceof MyClass ? x : null);
 * ```
 *
 * Nullable custom types can be created by composing with `nullable()` or
 * `voidable()` checkers:
 *
 * ```jsx
 * const maybeMyClassChecker =
 *   nullable(custom(x => x instanceof MyClass ? x : null));
 * ```
 */


function custom(checkValue, failureMessage = `failed to return non-null from custom checker.`) {
  return (value, path = new Path$3()) => {
    try {
      const checked = checkValue(value);
      return checked != null ? success$3(checked, []) : failure$3(failureMessage, path);
    } catch (error) {
      return failure$3(error.message, path);
    }
  };
}

var Refine_UtilityCheckers = {
  or,
  union,
  match,
  nullable,
  voidable,
  withDefault,
  constraint,
  asType,
  lazy,
  custom
};

const {
  assertion: assertion$2,
  coercion: coercion$1
} = Refine_API;

const {
  Path: Path$4
} = Refine_Checkers$1;

const {
  array: array$1,
  dict: dict$1,
  map: map$1,
  object: object$1,
  optional: optional$1,
  set: set$1,
  tuple: tuple$1,
  writableArray: writableArray$1,
  writableDict: writableDict$1,
  writableObject: writableObject$1
} = Refine_ContainerCheckers$1;

const {
  jsonParser: jsonParser$1,
  jsonParserEnforced: jsonParserEnforced$1
} = Refine_JSON;

const {
  bool: bool$1,
  date: date$1,
  enumObject: enumObject$1,
  jsonDate: jsonDate$1,
  literal: literal$1,
  mixed: mixed$1,
  number: number$1,
  string: string$1,
  stringLiterals: stringLiterals$1
} = Refine_PrimitiveCheckers;

const {
  asType: asType$1,
  constraint: constraint$1,
  custom: custom$1,
  lazy: lazy$1,
  match: match$1,
  nullable: nullable$1,
  or: or$1,
  union: union$1,
  voidable: voidable$1,
  withDefault: withDefault$1
} = Refine_UtilityCheckers;

var Refine_index = {
  // API
  assertion: assertion$2,
  coercion: coercion$1,
  jsonParser: jsonParser$1,
  jsonParserEnforced: jsonParserEnforced$1,
  Path: Path$4,
  // Checkers - Primitives
  mixed: mixed$1,
  literal: literal$1,
  bool: bool$1,
  number: number$1,
  string: string$1,
  stringLiterals: stringLiterals$1,
  enumObject: enumObject$1,
  date: date$1,
  jsonDate: jsonDate$1,
  // Checkers - Utility
  asType: asType$1,
  or: or$1,
  union: union$1,
  match: match$1,
  nullable: nullable$1,
  voidable: voidable$1,
  withDefault: withDefault$1,
  constraint: constraint$1,
  lazy: lazy$1,
  custom: custom$1,
  // Checkers - Containers
  array: array$1,
  tuple: tuple$1,
  dict: dict$1,
  object: object$1,
  optional: optional$1,
  set: set$1,
  map: map$1,
  writableArray: writableArray$1,
  writableDict: writableDict$1,
  writableObject: writableObject$1
};

const {
  DefaultValue: DefaultValue$1,
  RecoilLoadable: RecoilLoadable$1
} = recoil;

const {
  syncEffect: syncEffect$1,
  useRecoilSync: useRecoilSync$1
} = RecoilSync$1;



const {
  useCallback: useCallback$1,
  useEffect: useEffect$1,
  useMemo,
  useRef: useRef$1
} = react;



const {
  assertion: assertion$3,
  mixed: mixed$2,
  writableDict: writableDict$2
} = Refine_index;

const registries$1 = new Map();
const itemStateChecker = writableDict$2(mixed$2());
const refineState = assertion$3(itemStateChecker);

const wrapState = x => {
  return new Map(Array.from(Object.entries(refineState(x))));
};

const unwrapState = state => Object.fromEntries(Array.from(state.entries()) // Only serialize atoms in a non-default value state.
.filter(([, value]) => !(value instanceof DefaultValue$1)));

function parseURL(href, loc, deserialize) {
  const url = new URL(href);

  switch (loc.part) {
    case 'href':
      return wrapState(deserialize(`${url.pathname}${url.search}${url.hash}`));

    case 'hash':
      return url.hash ? wrapState(deserialize(decodeURIComponent(url.hash.substr(1)))) : null;

    case 'search':
      return url.search ? wrapState(deserialize(decodeURIComponent(url.search.substr(1)))) : null;

    case 'queryParams':
      {
        const searchParams = new URLSearchParams(url.search);
        const {
          param
        } = loc;

        if (param != null) {
          const stateStr = searchParams.get(param);
          return stateStr != null ? wrapState(deserialize(stateStr)) : new Map();
        }

        return new Map(Array.from(searchParams.entries()).map(([key, value]) => {
          try {
            return [key, deserialize(value)];
          } catch (error) {
            return [key, RecoilLoadable$1.error(error)];
          }
        }));
      }
  }

  throw Recoil_err(`Unknown URL location part: "${loc.part}"`);
}

function encodeURL(href, loc, items, serialize) {
  const url = new URL(href);

  switch (loc.part) {
    case 'href':
      return serialize(unwrapState(items));

    case 'hash':
      url.hash = encodeURIComponent(serialize(unwrapState(items)));
      break;

    case 'search':
      url.search = encodeURIComponent(serialize(unwrapState(items)));
      break;

    case 'queryParams':
      {
        const {
          param
        } = loc;
        const searchParams = new URLSearchParams(url.search);

        if (param != null) {
          searchParams.set(param, serialize(unwrapState(items)));
        } else {
          for (const [itemKey, value] of items.entries()) {
            value instanceof DefaultValue$1 ? searchParams.delete(itemKey) : searchParams.set(itemKey, serialize(value));
          }
        }

        url.search = searchParams.toString();
        break;
      }

    default:
      throw Recoil_err(`Unknown URL location part: "${loc.part}"`);
  }

  return url.href;
} ///////////////////////
// useRecoilURLSync()
///////////////////////


const DEFAULT_BROWSER_INTERFACE = {
  replaceURL: url => history.replaceState(null, '', url),
  pushURL: url => history.pushState(null, '', url),
  getURL: () => window.document.location,
  listenChangeURL: handleUpdate => {
    window.addEventListener('popstate', handleUpdate);
    return () => window.removeEventListener('popstate', handleUpdate);
  }
};

function RecoilURLSync({
  storeKey,
  location: loc,
  serialize,
  deserialize,
  browserInterface,
  children
}) {
  const {
    getURL,
    replaceURL,
    pushURL,
    listenChangeURL
  } = { ...DEFAULT_BROWSER_INTERFACE,
    ...(browserInterface !== null && browserInterface !== void 0 ? browserInterface : {})
  }; // Parse and cache the current state from the URL
  // Update cached URL parsing if properties of location prop change, but not
  // based on just the object reference itself.

  const memoizedLoc = useMemo(() => loc, // Complications with disjoint uniont
  // $FlowIssue[prop-missing]
  [loc.part, loc.queryParam] // eslint-disable-line fb-www/react-hooks-deps
  );
  const updateCachedState = useCallback$1(() => {
    cachedState.current = parseURL(getURL(), memoizedLoc, deserialize);
  }, [getURL, memoizedLoc, deserialize]);
  const cachedState = useRef$1(null); // Avoid executing updateCachedState() on each render

  const firstRender = useRef$1(true);
  firstRender.current && updateCachedState();
  firstRender.current = false;
  useEffect$1(updateCachedState, [updateCachedState]);
  const write = useCallback$1(({
    diff,
    allItems
  }) => {
    updateCachedState(); // Just to be safe...
    // This could be optimized with an itemKey-based registery if necessary to avoid
    // atom traversal.

    const atomRegistry = registries$1.get(storeKey);
    const itemsToPush = atomRegistry != null ? new Set(Array.from(atomRegistry).filter(([, {
      history,
      itemKeys
    }]) => history === 'push' && Array.from(itemKeys).some(key => diff.has(key))).map(([, {
      itemKeys
    }]) => itemKeys).reduce((itemKeys, keys) => itemKeys.concat(Array.from(keys)), [])) : null;

    if (itemsToPush !== null && itemsToPush !== void 0 && itemsToPush.size && cachedState.current != null) {
      const replaceItems = cachedState.current; // First, repalce the URL with any atoms that replace the URL history

      for (const [key, value] of allItems) {
        if (!itemsToPush.has(key)) {
          replaceItems.set(key, value);
        }
      }

      replaceURL(encodeURL(getURL(), loc, replaceItems, serialize)); // Next, push the URL with any atoms that caused a new URL history entry

      pushURL(encodeURL(getURL(), loc, allItems, serialize));
    } else {
      // Just replace the URL with the new state
      replaceURL(encodeURL(getURL(), loc, allItems, serialize));
    }

    cachedState.current = allItems;
  }, [getURL, loc, pushURL, replaceURL, serialize, storeKey, updateCachedState]);
  const read = useCallback$1(itemKey => {
    var _cachedState$current, _cachedState$current2;

    return (_cachedState$current = cachedState.current) !== null && _cachedState$current !== void 0 && _cachedState$current.has(itemKey) ? (_cachedState$current2 = cachedState.current) === null || _cachedState$current2 === void 0 ? void 0 : _cachedState$current2.get(itemKey) : new DefaultValue$1();
  }, []);
  const listen = useCallback$1(({
    updateAllKnownItems
  }) => {
    function handleUpdate() {
      updateCachedState();

      if (cachedState.current != null) {
        updateAllKnownItems(cachedState.current);
      }
    }

    return listenChangeURL(handleUpdate);
  }, [listenChangeURL, updateCachedState]);
  useRecoilSync$1({
    storeKey,
    read,
    write,
    listen
  });
  return children;
} ///////////////////////
// urlSyncEffect()
///////////////////////


function urlSyncEffect({
  history = 'replace',
  ...options
}) {
  const atomEffect = syncEffect$1(options);
  return effectArgs => {
    var _options$itemKey;

    // Register URL sync options
    if (!registries$1.has(options.storeKey)) {
      registries$1.set(options.storeKey, new Map());
    }

    const atomRegistry = registries$1.get(options.storeKey);

    if (atomRegistry == null) {
      throw Recoil_err('Error with atom registration');
    }

    atomRegistry.set(effectArgs.node.key, {
      history,
      itemKeys: new Set([(_options$itemKey = options.itemKey) !== null && _options$itemKey !== void 0 ? _options$itemKey : effectArgs.node.key])
    }); // Wrap syncEffect() atom effect

    const cleanup = atomEffect(effectArgs); // Cleanup atom option registration

    return () => {
      atomRegistry.delete(effectArgs.node.key);
      cleanup === null || cleanup === void 0 ? void 0 : cleanup();
    };
  };
}

var RecoilSync_URL = {
  RecoilURLSync,
  urlSyncEffect
};

function nullthrows(x, message) {
  if (x != null) {
    return x;
  }

  throw Recoil_err(message !== null && message !== void 0 ? message : 'Got unexpected null or undefined');
}

var Recoil_nullthrows = nullthrows;

const {
  RecoilURLSync: RecoilURLSync$1
} = RecoilSync_URL;



const {
  useCallback: useCallback$2
} = react;





function RecoilURLSyncJSON(options) {
  if (options.location.part === 'href') {
    throw Recoil_err('"href" location is not supported for JSON encoding');
  }

  const serialize = useCallback$2(x => x === undefined ? '' : Recoil_nullthrows(JSON.stringify(x), 'Unable to serialize state with JSON'), []);
  const deserialize = useCallback$2(x => JSON.parse(x), []);
  return /*#__PURE__*/react.createElement(RecoilURLSync$1, _extends({}, options, {
    serialize,
    deserialize
  }));
}

var RecoilSync_URLJSON = {
  RecoilURLSyncJSON
};

var RecoilSync_URLJSON_1 = RecoilSync_URLJSON.RecoilURLSyncJSON;

var RecoilSync_URLJSON$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  RecoilURLSyncJSON: RecoilSync_URLJSON_1
});

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function sprintf(format, ...args) {
  let index = 0;
  return format.replace(/%s/g, () => String(args[index++]));
}

var sprintf_1 = sprintf;

function expectationViolation(format, ...args) {
  if (process.env.NODE_ENV !== "production") {
    const message = sprintf_1.call(null, format, ...args);
    const error = new Error(message);
    error.name = 'Expectation Violation';
    console.error(error);
  }
}

var expectationViolation_1 = expectationViolation;

// @oss-only


var Recoil_expectationViolation = expectationViolation_1;

const {
  useEffect: useEffect$2,
  useRef: useRef$2
} = react;

function usePrevious(value) {
  const ref = useRef$2();
  useEffect$2(() => {
    ref.current = value;
  });
  return ref.current;
}

var Recoil_usePrevious = usePrevious;

const {
  DefaultValue: DefaultValue$2
} = recoil;

const {
  RecoilURLSync: RecoilURLSync$2
} = RecoilSync_URL;



const {
  useCallback: useCallback$3,
  useEffect: useEffect$3,
  useMemo: useMemo$1
} = react;









const BUILTIN_HANDLERS = [{
  tag: 'Date',
  class: Date,

  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by
   * Flow's LTI update could not be added via codemod */
  write: x => x.toISOString(),
  read: str => new Date(str)
}, {
  tag: 'Set',
  class: Set,

  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by
   * Flow's LTI update could not be added via codemod */
  write: x => Array.from(x),
  read: arr => new Set(arr)
}, {
  tag: 'Map',
  class: Map,

  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by
   * Flow's LTI update could not be added via codemod */
  write: x => Array.from(x.entries()),
  read: arr => new Map(arr)
}, {
  tag: '__DV',
  class: DefaultValue$2,
  write: () => 0,
  // number encodes the smallest in URL
  read: () => new DefaultValue$2()
}];

function RecoilURLSyncTransit({
  handlers: handlersProp,
  ...options
}) {
  if (options.location.part === 'href') {
    throw Recoil_err('"href" location is not supported for Transit encoding');
  }

  const previousHandlers = Recoil_usePrevious(handlersProp);
  useEffect$3(() => {
    if (process.env.NODE_ENV !== "production") {
      if (previousHandlers != null && previousHandlers !== handlersProp) {
        const message = `<RecoilURLSyncTransit> 'handlers' prop was detected to be unstable.
          It is important that this is a stable or memoized array instance.
          Otherwise you may miss URL changes as the listener is re-subscribed.
        `;
        Recoil_expectationViolation(message);
      }
    }
  }, [previousHandlers, handlersProp]);
  const handlers = useMemo$1(() => [...BUILTIN_HANDLERS, ...(handlersProp !== null && handlersProp !== void 0 ? handlersProp : [])], [handlersProp]);
  const writer = useMemo$1(() => transitJs.writer('json', {
    handlers: transitJs.map(handlers.map(handler => [handler.class, transitJs.makeWriteHandler({
      tag: () => handler.tag,
      rep: handler.write
    })]).flat(1))
  }), [handlers]);
  const serialize = useCallback$3(x => writer.write(x), [writer]);
  const reader = useMemo$1(() => transitJs.reader('json', {
    handlers: handlers.reduce((c, {
      tag,
      read
    }) => {
      c[tag] = read;
      return c;
    }, {}),
    mapBuilder: {
      init: () => ({}),
      add: (ret, key, val) => {
        ret[key] = val;
        return ret;
      },
      finalize: ret => ret
    }
  }), [handlers]);
  const deserialize = useCallback$3(x => reader.read(x), [reader]);
  return /*#__PURE__*/react.createElement(RecoilURLSync$2, _extends({}, options, {
    serialize,
    deserialize
  }));
}

var RecoilSync_URLTransit = {
  RecoilURLSyncTransit
};

var RecoilSync_URLTransit_1 = RecoilSync_URLTransit.RecoilURLSyncTransit;

var RecoilSync_URLTransit$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  RecoilURLSyncTransit: RecoilSync_URLTransit_1
});

const {
  RecoilSync: RecoilSync$2,
  syncEffect: syncEffect$2
} = RecoilSync$1;

const {
  RecoilURLSync: RecoilURLSync$3,
  urlSyncEffect: urlSyncEffect$1
} = RecoilSync_URL;

const {
  RecoilURLSyncJSON: RecoilURLSyncJSON$1
} = RecoilSync_URLJSON$1;

const {
  RecoilURLSyncTransit: RecoilURLSyncTransit$1
} = RecoilSync_URLTransit$1;

var RecoilSync_index = {
  // Core Recoil Sync
  RecoilSync: RecoilSync$2,
  syncEffect: syncEffect$2,
  // Recoil Sync URL
  RecoilURLSync: RecoilURLSync$3,
  RecoilURLSyncJSON: RecoilURLSyncJSON$1,
  RecoilURLSyncTransit: RecoilURLSyncTransit$1,
  urlSyncEffect: urlSyncEffect$1
};
var RecoilSync_index_1 = RecoilSync_index.RecoilSync;
var RecoilSync_index_2 = RecoilSync_index.syncEffect;
var RecoilSync_index_3 = RecoilSync_index.RecoilURLSync;
var RecoilSync_index_4 = RecoilSync_index.RecoilURLSyncJSON;
var RecoilSync_index_5 = RecoilSync_index.RecoilURLSyncTransit;
var RecoilSync_index_6 = RecoilSync_index.urlSyncEffect;

export default RecoilSync_index;
export { RecoilSync_index_1 as RecoilSync, RecoilSync_index_3 as RecoilURLSync, RecoilSync_index_4 as RecoilURLSyncJSON, RecoilSync_index_5 as RecoilURLSyncTransit, RecoilSync_index_2 as syncEffect, RecoilSync_index_6 as urlSyncEffect };
