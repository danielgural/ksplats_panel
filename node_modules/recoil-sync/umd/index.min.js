!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports,require("recoil"),require("react"),require("transit-js")):"function"==typeof define&&define.amd?define(["exports","recoil","react","transit-js"],factory):factory((global=global||self).RecoilSync={},global.Recoil,global.React,global.transit)}(this,(function(exports,recoil,react,transitJs){"use strict";recoil=recoil&&Object.prototype.hasOwnProperty.call(recoil,"default")?recoil.default:recoil,react=react&&Object.prototype.hasOwnProperty.call(react,"default")?react.default:react,transitJs=transitJs&&Object.prototype.hasOwnProperty.call(transitJs,"default")?transitJs.default:transitJs;var Recoil_err=function(message){const error=new Error(message);if(void 0===error.stack)try{throw error}catch(_){}return error};var Recoil_lazyProxy=function(base,factories){return new Proxy(base,{get:(target,prop)=>(!(prop in target)&&prop in factories&&(target[prop]=factories[prop]()),target[prop]),ownKeys:target=>Object.keys(target)})};function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _extends(){return(_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target}).apply(this,arguments)}const{DefaultValue:DefaultValue,RecoilLoadable:RecoilLoadable,useRecoilSnapshot:useRecoilSnapshot,useRecoilStoreID:useRecoilStoreID,useRecoilTransaction_UNSTABLE:useRecoilTransaction_UNSTABLE}=recoil,{useCallback:useCallback,useEffect:useEffect,useRef:useRef}=react,DEFAULT_VALUE=new DefaultValue;function setIntersectsMap(a,b){if(a.size<=b.size){for(const x of a)if(b.has(x))return!0}else for(const x of b.keys())if(a.has(x))return!0;return!1}const registries=new class{constructor(){_defineProperty(this,"atomRegistries",new Map),_defineProperty(this,"nextEffectKey",0),_defineProperty(this,"storageRegistries",new Map)}getAtomRegistry(recoilStoreID,externalStoreKey){this.atomRegistries.has(recoilStoreID)||this.atomRegistries.set(recoilStoreID,new Map);const storeRegistries=this.atomRegistries.get(recoilStoreID),registry=null==storeRegistries?void 0:storeRegistries.get(externalStoreKey);if(null!=registry)return registry;const newRegistry=new Map;return null==storeRegistries||storeRegistries.set(externalStoreKey,newRegistry),newRegistry}setAtomEffect(recoilStoreID,externalStoreKey,node,options){var _atomRegistry$get;const atomRegistry=this.getAtomRegistry(recoilStoreID,externalStoreKey);atomRegistry.has(node.key)||atomRegistry.set(node.key,{atom:node,effects:new Map});const effectKey=this.nextEffectKey++,effectRegistration={options:options,subscribedItemKeys:new Set([options.itemKey])};return null===(_atomRegistry$get=atomRegistry.get(node.key))||void 0===_atomRegistry$get||_atomRegistry$get.effects.set(effectKey,effectRegistration),{effectRegistration:effectRegistration,unregisterEffect:()=>{var _atomRegistry$get2;null===(_atomRegistry$get2=atomRegistry.get(node.key))||void 0===_atomRegistry$get2||_atomRegistry$get2.effects.delete(effectKey)}}}getStorage(recoilStoreID,externalStoreKey){var _this$storageRegistri;return null===(_this$storageRegistri=this.storageRegistries.get(recoilStoreID))||void 0===_this$storageRegistri?void 0:_this$storageRegistri.get(externalStoreKey)}setStorage(recoilStoreID,externalStoreKey,storage){var _this$storageRegistri2;return this.storageRegistries.has(recoilStoreID)||this.storageRegistries.set(recoilStoreID,new Map),null===(_this$storageRegistri2=this.storageRegistries.get(recoilStoreID))||void 0===_this$storageRegistri2||_this$storageRegistri2.set(externalStoreKey,storage),()=>{var _this$storageRegistri3;null===(_this$storageRegistri3=this.storageRegistries.get(recoilStoreID))||void 0===_this$storageRegistri3||_this$storageRegistri3.delete(externalStoreKey)}}};function readAtomItems(effectRegistration,readFromStorage,diff){const{options:options}=effectRegistration,readFromStorageRequired=null!=readFromStorage?readFromStorage:itemKey=>RecoilLoadable.error(`Read functionality not provided for ${null!=options.storeKey?`"${options.storeKey}" `:""}store in useRecoilSync() hook while updating item "${itemKey}".`);effectRegistration.subscribedItemKeys=new Set;const read=itemKey=>{effectRegistration.subscribedItemKeys.add(itemKey);const value=null!=diff&&diff.has(itemKey)?null==diff?void 0:diff.get(itemKey):readFromStorageRequired(itemKey);if(RecoilLoadable.isLoadable(value)){const loadable=value;if("hasError"===loadable.state)throw loadable.contents}return value};let value;try{value=options.read({read:read})}catch(error){return RecoilLoadable.error(error)}return value instanceof DefaultValue?null:function(input,{refine:refine,actionOnFailure_UNSTABLE:actionOnFailure_UNSTABLE}){return RecoilLoadable.of(input).map(x=>{if(x instanceof DefaultValue)return x;const result=refine(x);if("success"===result.type)return result.value;if("defaultValue"===actionOnFailure_UNSTABLE)return new DefaultValue;throw Recoil_err(`[${result.path.toString()}]: ${result.message}`)})}(value,options)}function writeAtomItemsToDiff(diff,options,readFromStorage,loadable){if(null!=loadable&&"hasValue"!==(null==loadable?void 0:loadable.state))return diff;const readFromStorageRequired=null!=readFromStorage?readFromStorage:_=>{throw Recoil_err(`Read functionality not provided for ${null!=options.storeKey?`"${options.storeKey}" `:""}store in useRecoilSync() hook while writing item "${options.itemKey}".`)};return options.write({write:(k,l)=>{diff.set(k,l)},reset:k=>{diff.set(k,DEFAULT_VALUE)},read:itemKey=>diff.has(itemKey)?diff.get(itemKey):readFromStorageRequired(itemKey)},null==loadable?DEFAULT_VALUE:loadable.contents),diff}function getWriteInterface(recoilStoreID,storeKey,diff,getInfo){return Recoil_lazyProxy({diff:diff},{allItems:()=>((recoilStoreID,storeKey,getInfo)=>{const items=new Map;for(const[,{atom:atom,effects:effects}]of registries.getAtomRegistry(recoilStoreID,storeKey))for(const[,{options:options}]of effects){var _registries$getStorag;const atomInfo=getInfo(atom);writeAtomItemsToDiff(items,options,null===(_registries$getStorag=registries.getStorage(recoilStoreID,storeKey))||void 0===_registries$getStorag?void 0:_registries$getStorag.read,atomInfo.isSet||!0===options.syncDefault?atomInfo.loadable:null)}return items})(recoilStoreID,storeKey,getInfo)})}function useRecoilSync({storeKey:storeKey,write:write,read:read,listen:listen}){const recoilStoreID=useRecoilStoreID(),snapshot=useRecoilSnapshot(),previousSnapshotRef=useRef(snapshot);useEffect(()=>{if(null!=write&&snapshot!==previousSnapshotRef.current){previousSnapshotRef.current=snapshot;const diff=new Map,atomRegistry=registries.getAtomRegistry(recoilStoreID,storeKey),modifiedAtoms=snapshot.getNodes_UNSTABLE({isModified:!0});for(const atom of modifiedAtoms){const registration=atomRegistry.get(atom.key);if(null!=registration){var _atomInfo$loadable,_registration$pending,_registration$pending2;const atomInfo=snapshot.getInfo_UNSTABLE(registration.atom);if(atomInfo.isSet&&(null===(_atomInfo$loadable=atomInfo.loadable)||void 0===_atomInfo$loadable?void 0:_atomInfo$loadable.contents)!==(null===(_registration$pending=registration.pendingUpdate)||void 0===_registration$pending?void 0:_registration$pending.value)||!atomInfo.isSet&&!((null===(_registration$pending2=registration.pendingUpdate)||void 0===_registration$pending2?void 0:_registration$pending2.value)instanceof DefaultValue))for(const[,{options:options}]of registration.effects)writeAtomItemsToDiff(diff,options,read,atomInfo.isSet||!0===options.syncDefault?atomInfo.loadable:null);delete registration.pendingUpdate}}diff.size&&write(getWriteInterface(recoilStoreID,storeKey,diff,snapshot.getInfo_UNSTABLE))}},[read,recoilStoreID,snapshot,storeKey,write]);const updateItems=useRecoilTransaction_UNSTABLE(({set:set,reset:reset})=>diff=>{const atomRegistry=registries.getAtomRegistry(recoilStoreID,storeKey);for(const[,atomRegistration]of atomRegistry)for(const[,effectRegistration]of Array.from(atomRegistration.effects).reverse()){const{options:options,subscribedItemKeys:subscribedItemKeys}=effectRegistration;if(setIntersectsMap(subscribedItemKeys,diff)){const loadable=readAtomItems(effectRegistration,read,diff);if(null!=loadable){switch(loadable.state){case"hasValue":loadable.contents instanceof DefaultValue?(atomRegistration.pendingUpdate={value:DEFAULT_VALUE},reset(atomRegistration.atom)):(atomRegistration.pendingUpdate={value:loadable.contents},set(atomRegistration.atom,loadable.contents));break;case"hasError":"errorState"===options.actionOnFailure_UNSTABLE&&(atomRegistration.pendingUpdate={value:DEFAULT_VALUE},reset(atomRegistration.atom));break;case"loading":throw Recoil_err("Recoil does not yet support setting atoms to an asynchronous state")}break}atomRegistration.pendingUpdate={value:DEFAULT_VALUE},reset(atomRegistration.atom)}}},[recoilStoreID,storeKey,read]),updateItem=useCallback((itemKey,newValue)=>{updateItems(new Map([[itemKey,newValue]]))},[updateItems]),updateAllKnownItems=useCallback(itemSnapshot=>{const atomRegistry=registries.getAtomRegistry(recoilStoreID,storeKey);for(const[,registration]of atomRegistry)for(const[,{subscribedItemKeys:subscribedItemKeys}]of registration.effects)for(const itemKey of subscribedItemKeys)itemSnapshot.has(itemKey)||itemSnapshot.set(itemKey,DEFAULT_VALUE);updateItems(itemSnapshot)},[recoilStoreID,storeKey,updateItems]);useEffect(()=>null==listen?void 0:listen({updateItem:updateItem,updateItems:updateItems,updateAllKnownItems:updateAllKnownItems}),[updateItem,updateItems,updateAllKnownItems,listen]),registries.setStorage(recoilStoreID,storeKey,{write:write,read:read}),useEffect(()=>registries.setStorage(recoilStoreID,storeKey,{write:write,read:read}),[recoilStoreID,storeKey,read,write])}var RecoilSync_1={useRecoilSync:useRecoilSync,RecoilSync:function({children:children,...props}){return useRecoilSync(props),children},syncEffect:function(opt){return({node:node,trigger:trigger,storeID:storeID,setSelf:setSelf,getLoadable:getLoadable,getInfo_UNSTABLE:getInfo_UNSTABLE})=>{var _opt$itemKey;const itemKey=null!==(_opt$itemKey=opt.itemKey)&&void 0!==_opt$itemKey?_opt$itemKey:node.key,options={itemKey:itemKey,read:({read:read})=>read(itemKey),write:({write:write},loadable)=>write(itemKey,loadable),syncDefault:!1,actionOnFailure_UNSTABLE:"errorState",...opt},{storeKey:storeKey}=options,storage=registries.getStorage(storeID,storeKey),{effectRegistration:effectRegistration,unregisterEffect:unregisterEffect}=registries.setAtomEffect(storeID,storeKey,node,options);if("get"===trigger){const readFromStorage=null==storage?void 0:storage.read;if(null!=readFromStorage)try{const loadable=readAtomItems(effectRegistration,readFromStorage);if(null!=loadable)switch(loadable.state){case"hasValue":loadable.contents instanceof DefaultValue||setSelf(loadable.contents);break;case"hasError":if("errorState"===options.actionOnFailure_UNSTABLE)throw loadable.contents;break;case"loading":setSelf(loadable.toPromise())}}catch(error){if("errorState"===options.actionOnFailure_UNSTABLE)throw error}const writeToStorage=null==storage?void 0:storage.write;!0===options.syncDefault&&null!=writeToStorage&&window.setTimeout(()=>{const loadable=getLoadable(node);if("hasValue"===loadable.state){const diff=writeAtomItemsToDiff(new Map,options,null==storage?void 0:storage.read,loadable);writeToStorage(getWriteInterface(storeID,storeKey,diff,getInfo_UNSTABLE))}},0)}return unregisterEffect}},registries_FOR_TESTING:registries},RecoilSync_2=RecoilSync_1.useRecoilSync,RecoilSync_3=RecoilSync_1.RecoilSync,RecoilSync_4=RecoilSync_1.syncEffect,RecoilSync_5=RecoilSync_1.registries_FOR_TESTING,RecoilSync$1=Object.freeze({__proto__:null,useRecoilSync:RecoilSync_2,RecoilSync:RecoilSync_3,syncEffect:RecoilSync_4,registries_FOR_TESTING:RecoilSync_5});var Refine_API={assertion:function(checker,errorMessage="assertion error"){return value=>{const result=checker(value);return"success"===result.type?result.value:function(suffix,resultFailure){if(null!=resultFailure){const path=resultFailure.path.toString(),message=resultFailure.message;throw Recoil_err(`[refine.js (path=${path}, message=${message})]: ${suffix}`)}throw Recoil_err("[refine.js (null result)]: "+suffix)}(errorMessage,result)}},coercion:function(checker,onResult){return value=>{const result=checker(value);return null!=onResult&&onResult(result),"success"===result.type?result.value:null}}};class Path{constructor(parent=null,field="<root>"){_defineProperty(this,"parent",void 0),_defineProperty(this,"field",void 0),this.parent=parent,this.field=field}extend(field){return new Path(this,field)}toString(){const pieces=[];let current=this;for(;null!=current;){const{field:field,parent:parent}=current;pieces.push(field),current=parent}return pieces.reverse().join("")}}var Refine_Checkers_1=Path,Refine_Checkers_2=function(value,warnings){return{type:"success",value:value,warnings:warnings}},Refine_Checkers_3=function(message,path){return{type:"failure",message:message,path:path}},Refine_Checkers_4=function(checker,next){return(value,path=new Path)=>{const result=checker(value,path);return"failure"===result.type?result:next(result,path)}},Refine_Checkers$1=Object.freeze({__proto__:null,Path:Refine_Checkers_1,success:Refine_Checkers_2,failure:Refine_Checkers_3,compose:Refine_Checkers_4});const{Path:Path$1,compose:compose$1,failure:failure$1,success:success$1}=Refine_Checkers$1;function isPlainObject(value){if("[object Object]"!==Object.prototype.toString.call(value))return!1;const prototype=Object.getPrototypeOf(value);return null===prototype||prototype===Object.prototype}function array(valueChecker){return(value,path=new Path$1)=>{if(!Array.isArray(value))return failure$1("value is not an array",path);const len=value.length,out=new Array(len),warnings=[];for(let i=0;i<len;i++){const element=value[i],result=valueChecker(element,path.extend(`[${i}]`));if("failure"===result.type)return failure$1(result.message,result.path);out[i]=result.value,0!==result.warnings.length&&warnings.push(...result.warnings)}return success$1(out,warnings)}}function dict(valueChecker){return(value,path=new Path$1)=>{if("object"!=typeof value||null===value||!isPlainObject(value))return failure$1("value is not an object",path);const out={},warnings=[];for(const[key,element]of Object.entries(value)){const result=valueChecker(element,path.extend("."+key));if("failure"===result.type)return failure$1(result.message,result.path);out[key]=result.value,0!==result.warnings.length&&warnings.push(...result.warnings)}return success$1(out,warnings)}}class OptionalProperty{constructor(checker){_defineProperty(this,"checker",void 0),this.checker=checker}}function object(checkers){const checkerProperties=Object.keys(checkers);return(value,path=new Path$1)=>{if("object"!=typeof value||null===value||!isPlainObject(value))return failure$1("value is not an object",path);const out={},warnings=[];for(const key of checkerProperties){const provided=checkers[key];let check,element;if(provided instanceof OptionalProperty){if(check=provided.checker,!value.hasOwnProperty(key))continue;element=value[key]}else check=provided,element=value.hasOwnProperty(key)?value[key]:void 0;const result=check(element,path.extend("."+key));if("failure"===result.type)return failure$1(result.message,result.path);out[key]=result.value,0!==result.warnings.length&&warnings.push(...result.warnings)}return success$1(out,warnings)}}var Refine_ContainerCheckers_1=array,Refine_ContainerCheckers_2=function(...checkers){return(value,path=new Path$1)=>{if(!Array.isArray(value))return failure$1("value is not an array",path);const out=new Array(checkers.length),warnings=[];for(const[i,checker]of checkers.entries()){const result=checker(value[i],path.extend(`[${i}]`));if("failure"===result.type)return failure$1(result.message,result.path);out[i]=result.value,0!==result.warnings.length&&warnings.push(...result.warnings)}return success$1(out,warnings)}},Refine_ContainerCheckers_3=object,Refine_ContainerCheckers_4=function(checker){return new OptionalProperty((value,path=new Path$1)=>{const result=checker(value,path);return"failure"===result.type?{...result,message:"(optional property) "+result.message}:result})},Refine_ContainerCheckers_5=dict,Refine_ContainerCheckers_6=function(checker){return(value,path=new Path$1)=>{if(!(value instanceof Set))return failure$1("value is not a Set",path);const out=new Set,warnings=[];for(const item of value){const result=checker(item,path.extend("[]"));if("failure"===result.type)return failure$1(result.message,result.path);out.add(result.value),result.warnings.length&&warnings.push(...result.warnings)}return success$1(out,warnings)}},Refine_ContainerCheckers_7=function(keyChecker,valueChecker){return(value,path=new Path$1)=>{if(!(value instanceof Map))return failure$1("value is not a Map",path);const out=new Map,warnings=[];for(const[k,v]of value.entries()){const keyResult=keyChecker(k,path.extend(`[${k}] key`));if("failure"===keyResult.type)return failure$1(keyResult.message,keyResult.path);const valueResult=valueChecker(v,path.extend(`[${k}]`));if("failure"===valueResult.type)return failure$1(valueResult.message,valueResult.path);out.set(k,v),warnings.push(...keyResult.warnings,...valueResult.warnings)}return success$1(out,warnings)}},Refine_ContainerCheckers_8=function(valueChecker){return compose$1(array(valueChecker),({value:value,warnings:warnings})=>success$1([...value],warnings))},Refine_ContainerCheckers_9=function(valueChecker){return compose$1(dict(valueChecker),({value:value,warnings:warnings})=>success$1({...value},warnings))},Refine_ContainerCheckers_10=function(checkers){return compose$1(object(checkers),({value:value,warnings:warnings})=>success$1({...value},warnings))},Refine_ContainerCheckers$1=Object.freeze({__proto__:null,array:Refine_ContainerCheckers_1,tuple:Refine_ContainerCheckers_2,object:Refine_ContainerCheckers_3,optional:Refine_ContainerCheckers_4,dict:Refine_ContainerCheckers_5,set:Refine_ContainerCheckers_6,map:Refine_ContainerCheckers_7,writableArray:Refine_ContainerCheckers_8,writableDict:Refine_ContainerCheckers_9,writableObject:Refine_ContainerCheckers_10});const{assertion:assertion$1}=Refine_API;function tryParseJSONMixed(text,reviver){if(null==text)return null;try{return JSON.parse(text,reviver)}catch{return null}}var Refine_JSON={jsonParserEnforced:function(checker,suffix){const assertedChecker=assertion$1(checker,null!=suffix?suffix:"value is invalid");return rawJSON=>assertedChecker(tryParseJSONMixed(null!=rawJSON?rawJSON:""))},jsonParser:function(checker){return rawJSON=>{const result=checker(tryParseJSONMixed(rawJSON));return"success"===result.type?result.value:null}}};const{Path:Path$2,compose:compose$2,failure:failure$2,success:success$2}=Refine_Checkers$1;const MIXED_CHECKER=value=>success$2(value,[]);function string(regex){return(value,path=new Path$2)=>"string"!=typeof value?failure$2("value is not a string",path):null==regex||regex.test(value)?success$2(value,[]):failure$2("value does not match regex: "+regex.toString(),path)}function stringLiterals(enumValues){return(value,path=new Path$2)=>{if("string"!=typeof value)return failure$2("value must be a string",path);const out=enumValues[value];return null==out?failure$2("value is not one of "+Object.keys(enumValues).join(", "),path):success$2(out,[])}}var Refine_PrimitiveCheckers={mixed:function(){return MIXED_CHECKER},literal:function(literalValue){return(value,path=new Path$2)=>{var _str;return value===literalValue?success$2(literalValue,[]):failure$2("value is not literal "+(null!==(_str=(value=>JSON.stringify(value))(literalValue))&&void 0!==_str?_str:"void"),path)}},bool:function(){return(value,path=new Path$2)=>"boolean"==typeof value?success$2(value,[]):failure$2("value is not a boolean",path)},number:function(){return(value,path=new Path$2)=>"number"==typeof value?success$2(value,[]):failure$2("value is not a number",path)},string:string,stringLiterals:stringLiterals,date:function(){return(value,path=new Path$2)=>value instanceof Date?isNaN(value)?failure$2("invalid date",path):success$2(value,[]):failure$2("value is not a date",path)},jsonDate:function(){return compose$2(string(),({value:value,warnings:warnings},path)=>{const parsedDate=new Date(value);return Number.isNaN(parsedDate)?failure$2("value is not valid date string",path):success$2(parsedDate,warnings)})},enumObject:function(enumObj){const stringLiteralsChecker=stringLiterals(Object.keys(enumObj).reduce((res,key)=>Object.assign(res,{[enumObj[key]]:enumObj[key]}),{}));return(rawValue,path=new Path$2)=>{const value="number"==typeof rawValue?rawValue.toString():rawValue,result=stringLiteralsChecker(value,path);return"success"===result.type&&typeof result.value!=typeof rawValue?failure$2("input must be the same type as the enum values",path):result}}};const{Path:Path$3,compose:compose$3,failure:failure$3,success:success$3}=Refine_Checkers$1;function unionFailure(message,path,failures){return failure$3(`${message}: ${failures.map(f=>f.message).join(", ")}`,path)}function union(...checkers){return(value,path=new Path$3)=>{const failures=[];for(const checker of checkers){const result=checker(value,path);if("success"===result.type)return success$3(result.value,result.warnings);failures.push(result)}return unionFailure("value did not match any types in union",path,failures)}}var Refine_UtilityCheckers={or:function(aChecker,bChecker){return(value,path=new Path$3)=>{const a=aChecker(value,path);if("success"===a.type)return success$3(a.value,a.warnings);const b=bChecker(value,path);return"success"===b.type?success$3(b.value,b.warnings):unionFailure("value did not match any types in or()",path,[a,b])}},union:union,match:function(...checkers){return union(...checkers)},nullable:function(checker,options){const{nullWithWarningWhenInvalid:nullWithWarningWhenInvalid=!1}=null!=options?options:{};return(value,parentPath=new Path$3)=>{if(null==value)return success$3(value,[]);const result=checker(value,parentPath);if("success"===result.type)return success$3(result.value,result.warnings);if(nullWithWarningWhenInvalid)return success$3(null,[result]);const{message:message,path:path}=result;return failure$3(message,path)}},voidable:function(checker,options){const{undefinedWithWarningWhenInvalid:undefinedWithWarningWhenInvalid=!1}=null!=options?options:{};return(value,parentPath=new Path$3)=>{if(void 0===value)return success$3(void 0,[]);const result=checker(value,parentPath);if("success"===result.type)return success$3(result.value,result.warnings);if(undefinedWithWarningWhenInvalid)return success$3(void 0,[result]);const{message:message,path:path}=result;return failure$3(message,path)}},withDefault:function(checker,fallback){return(value,path=new Path$3)=>{if(null==value)return success$3(fallback,[]);const result=checker(value,path);return"failure"===result.type||null!=result.value?result:success$3(fallback,[])}},constraint:function(checker,predicate){return compose$3(checker,({value:value,warnings:warnings},path)=>{const result=predicate(value),[passed,message]="boolean"==typeof result?[result,"value failed constraint check"]:result;return passed?success$3(value,warnings):failure$3(message,path)})},asType:function(checker,cast){return compose$3(checker,({value:value,warnings:warnings})=>success$3(cast(value),warnings))},lazy:function(getChecker){return(value,path=new Path$3)=>getChecker()(value,path)},custom:function(checkValue,failureMessage="failed to return non-null from custom checker."){return(value,path=new Path$3)=>{try{const checked=checkValue(value);return null!=checked?success$3(checked,[]):failure$3(failureMessage,path)}catch(error){return failure$3(error.message,path)}}}};const{assertion:assertion$2,coercion:coercion$1}=Refine_API,{Path:Path$4}=Refine_Checkers$1,{array:array$1,dict:dict$1,map:map$1,object:object$1,optional:optional$1,set:set$1,tuple:tuple$1,writableArray:writableArray$1,writableDict:writableDict$1,writableObject:writableObject$1}=Refine_ContainerCheckers$1,{jsonParser:jsonParser$1,jsonParserEnforced:jsonParserEnforced$1}=Refine_JSON,{bool:bool$1,date:date$1,enumObject:enumObject$1,jsonDate:jsonDate$1,literal:literal$1,mixed:mixed$1,number:number$1,string:string$1,stringLiterals:stringLiterals$1}=Refine_PrimitiveCheckers,{asType:asType$1,constraint:constraint$1,custom:custom$1,lazy:lazy$1,match:match$1,nullable:nullable$1,or:or$1,union:union$1,voidable:voidable$1,withDefault:withDefault$1}=Refine_UtilityCheckers;var Refine_index={assertion:assertion$2,coercion:coercion$1,jsonParser:jsonParser$1,jsonParserEnforced:jsonParserEnforced$1,Path:Path$4,mixed:mixed$1,literal:literal$1,bool:bool$1,number:number$1,string:string$1,stringLiterals:stringLiterals$1,enumObject:enumObject$1,date:date$1,jsonDate:jsonDate$1,asType:asType$1,or:or$1,union:union$1,match:match$1,nullable:nullable$1,voidable:voidable$1,withDefault:withDefault$1,constraint:constraint$1,lazy:lazy$1,custom:custom$1,array:array$1,tuple:tuple$1,dict:dict$1,object:object$1,optional:optional$1,set:set$1,map:map$1,writableArray:writableArray$1,writableDict:writableDict$1,writableObject:writableObject$1};const{DefaultValue:DefaultValue$1,RecoilLoadable:RecoilLoadable$1}=recoil,{syncEffect:syncEffect$1,useRecoilSync:useRecoilSync$1}=RecoilSync$1,{useCallback:useCallback$1,useEffect:useEffect$1,useMemo:useMemo,useRef:useRef$1}=react,{assertion:assertion$3,mixed:mixed$2,writableDict:writableDict$2}=Refine_index,registries$1=new Map,refineState=assertion$3(writableDict$2(mixed$2())),wrapState=x=>new Map(Array.from(Object.entries(refineState(x)))),unwrapState=state=>Object.fromEntries(Array.from(state.entries()).filter(([,value])=>!(value instanceof DefaultValue$1)));function encodeURL(href,loc,items,serialize){const url=new URL(href);switch(loc.part){case"href":return serialize(unwrapState(items));case"hash":url.hash=encodeURIComponent(serialize(unwrapState(items)));break;case"search":url.search=encodeURIComponent(serialize(unwrapState(items)));break;case"queryParams":{const{param:param}=loc,searchParams=new URLSearchParams(url.search);if(null!=param)searchParams.set(param,serialize(unwrapState(items)));else for(const[itemKey,value]of items.entries())value instanceof DefaultValue$1?searchParams.delete(itemKey):searchParams.set(itemKey,serialize(value));url.search=searchParams.toString();break}default:throw Recoil_err(`Unknown URL location part: "${loc.part}"`)}return url.href}const DEFAULT_BROWSER_INTERFACE={replaceURL:url=>history.replaceState(null,"",url),pushURL:url=>history.pushState(null,"",url),getURL:()=>window.document.location,listenChangeURL:handleUpdate=>(window.addEventListener("popstate",handleUpdate),()=>window.removeEventListener("popstate",handleUpdate))};var RecoilSync_URL={RecoilURLSync:function({storeKey:storeKey,location:loc,serialize:serialize,deserialize:deserialize,browserInterface:browserInterface,children:children}){const{getURL:getURL,replaceURL:replaceURL,pushURL:pushURL,listenChangeURL:listenChangeURL}={...DEFAULT_BROWSER_INTERFACE,...null!=browserInterface?browserInterface:{}},memoizedLoc=useMemo(()=>loc,[loc.part,loc.queryParam]),updateCachedState=useCallback$1(()=>{cachedState.current=function(href,loc,deserialize){const url=new URL(href);switch(loc.part){case"href":return wrapState(deserialize(`${url.pathname}${url.search}${url.hash}`));case"hash":return url.hash?wrapState(deserialize(decodeURIComponent(url.hash.substr(1)))):null;case"search":return url.search?wrapState(deserialize(decodeURIComponent(url.search.substr(1)))):null;case"queryParams":{const searchParams=new URLSearchParams(url.search),{param:param}=loc;if(null!=param){const stateStr=searchParams.get(param);return null!=stateStr?wrapState(deserialize(stateStr)):new Map}return new Map(Array.from(searchParams.entries()).map(([key,value])=>{try{return[key,deserialize(value)]}catch(error){return[key,RecoilLoadable$1.error(error)]}}))}}throw Recoil_err(`Unknown URL location part: "${loc.part}"`)}(getURL(),memoizedLoc,deserialize)},[getURL,memoizedLoc,deserialize]),cachedState=useRef$1(null),firstRender=useRef$1(!0);firstRender.current&&updateCachedState(),firstRender.current=!1,useEffect$1(updateCachedState,[updateCachedState]);const write=useCallback$1(({diff:diff,allItems:allItems})=>{updateCachedState();const atomRegistry=registries$1.get(storeKey),itemsToPush=null!=atomRegistry?new Set(Array.from(atomRegistry).filter(([,{history:history,itemKeys:itemKeys}])=>"push"===history&&Array.from(itemKeys).some(key=>diff.has(key))).map(([,{itemKeys:itemKeys}])=>itemKeys).reduce((itemKeys,keys)=>itemKeys.concat(Array.from(keys)),[])):null;if(null!=itemsToPush&&itemsToPush.size&&null!=cachedState.current){const replaceItems=cachedState.current;for(const[key,value]of allItems)itemsToPush.has(key)||replaceItems.set(key,value);replaceURL(encodeURL(getURL(),loc,replaceItems,serialize)),pushURL(encodeURL(getURL(),loc,allItems,serialize))}else replaceURL(encodeURL(getURL(),loc,allItems,serialize));cachedState.current=allItems},[getURL,loc,pushURL,replaceURL,serialize,storeKey,updateCachedState]),read=useCallback$1(itemKey=>{var _cachedState$current,_cachedState$current2;return null!==(_cachedState$current=cachedState.current)&&void 0!==_cachedState$current&&_cachedState$current.has(itemKey)?null===(_cachedState$current2=cachedState.current)||void 0===_cachedState$current2?void 0:_cachedState$current2.get(itemKey):new DefaultValue$1},[]),listen=useCallback$1(({updateAllKnownItems:updateAllKnownItems})=>listenChangeURL((function(){updateCachedState(),null!=cachedState.current&&updateAllKnownItems(cachedState.current)})),[listenChangeURL,updateCachedState]);return useRecoilSync$1({storeKey:storeKey,read:read,write:write,listen:listen}),children},urlSyncEffect:function({history:history="replace",...options}){const atomEffect=syncEffect$1(options);return effectArgs=>{var _options$itemKey;registries$1.has(options.storeKey)||registries$1.set(options.storeKey,new Map);const atomRegistry=registries$1.get(options.storeKey);if(null==atomRegistry)throw Recoil_err("Error with atom registration");atomRegistry.set(effectArgs.node.key,{history:history,itemKeys:new Set([null!==(_options$itemKey=options.itemKey)&&void 0!==_options$itemKey?_options$itemKey:effectArgs.node.key])});const cleanup=atomEffect(effectArgs);return()=>{atomRegistry.delete(effectArgs.node.key),null==cleanup||cleanup()}}}};var Recoil_nullthrows=function(x,message){if(null!=x)return x;throw Recoil_err(null!=message?message:"Got unexpected null or undefined")};const{RecoilURLSync:RecoilURLSync$1}=RecoilSync_URL,{useCallback:useCallback$2}=react;var RecoilSync_URLJSON_1=function(options){if("href"===options.location.part)throw Recoil_err('"href" location is not supported for JSON encoding');const serialize=useCallback$2(x=>void 0===x?"":Recoil_nullthrows(JSON.stringify(x),"Unable to serialize state with JSON"),[]),deserialize=useCallback$2(x=>JSON.parse(x),[]);return react.createElement(RecoilURLSync$1,_extends({},options,{serialize:serialize,deserialize:deserialize}))},RecoilSync_URLJSON$1=Object.freeze({__proto__:null,RecoilURLSyncJSON:RecoilSync_URLJSON_1});const{useEffect:useEffect$2,useRef:useRef$2}=react;var Recoil_usePrevious=function(value){const ref=useRef$2();return useEffect$2(()=>{ref.current=value}),ref.current};const{DefaultValue:DefaultValue$2}=recoil,{RecoilURLSync:RecoilURLSync$2}=RecoilSync_URL,{useCallback:useCallback$3,useEffect:useEffect$3,useMemo:useMemo$1}=react,BUILTIN_HANDLERS=[{tag:"Date",class:Date,write:x=>x.toISOString(),read:str=>new Date(str)},{tag:"Set",class:Set,write:x=>Array.from(x),read:arr=>new Set(arr)},{tag:"Map",class:Map,write:x=>Array.from(x.entries()),read:arr=>new Map(arr)},{tag:"__DV",class:DefaultValue$2,write:()=>0,read:()=>new DefaultValue$2}];var RecoilSync_URLTransit_1=function({handlers:handlersProp,...options}){if("href"===options.location.part)throw Recoil_err('"href" location is not supported for Transit encoding');const previousHandlers=Recoil_usePrevious(handlersProp);useEffect$3(()=>{},[previousHandlers,handlersProp]);const handlers=useMemo$1(()=>[...BUILTIN_HANDLERS,...null!=handlersProp?handlersProp:[]],[handlersProp]),writer=useMemo$1(()=>transitJs.writer("json",{handlers:transitJs.map(handlers.map(handler=>[handler.class,transitJs.makeWriteHandler({tag:()=>handler.tag,rep:handler.write})]).flat(1))}),[handlers]),serialize=useCallback$3(x=>writer.write(x),[writer]),reader=useMemo$1(()=>transitJs.reader("json",{handlers:handlers.reduce((c,{tag:tag,read:read})=>(c[tag]=read,c),{}),mapBuilder:{init:()=>({}),add:(ret,key,val)=>(ret[key]=val,ret),finalize:ret=>ret}}),[handlers]),deserialize=useCallback$3(x=>reader.read(x),[reader]);return react.createElement(RecoilURLSync$2,_extends({},options,{serialize:serialize,deserialize:deserialize}))},RecoilSync_URLTransit$1=Object.freeze({__proto__:null,RecoilURLSyncTransit:RecoilSync_URLTransit_1});const{RecoilSync:RecoilSync$2,syncEffect:syncEffect$2}=RecoilSync$1,{RecoilURLSync:RecoilURLSync$3,urlSyncEffect:urlSyncEffect$1}=RecoilSync_URL,{RecoilURLSyncJSON:RecoilURLSyncJSON$1}=RecoilSync_URLJSON$1,{RecoilURLSyncTransit:RecoilURLSyncTransit$1}=RecoilSync_URLTransit$1;var RecoilSync_index={RecoilSync:RecoilSync$2,syncEffect:syncEffect$2,RecoilURLSync:RecoilURLSync$3,RecoilURLSyncJSON:RecoilURLSyncJSON$1,RecoilURLSyncTransit:RecoilURLSyncTransit$1,urlSyncEffect:urlSyncEffect$1},RecoilSync_index_1=RecoilSync_index.RecoilSync,RecoilSync_index_2=RecoilSync_index.syncEffect,RecoilSync_index_3=RecoilSync_index.RecoilURLSync,RecoilSync_index_4=RecoilSync_index.RecoilURLSyncJSON,RecoilSync_index_5=RecoilSync_index.RecoilURLSyncTransit,RecoilSync_index_6=RecoilSync_index.urlSyncEffect;exports.RecoilSync=RecoilSync_index_1,exports.RecoilURLSync=RecoilSync_index_3,exports.RecoilURLSyncJSON=RecoilSync_index_4,exports.RecoilURLSyncTransit=RecoilSync_index_5,exports.default=RecoilSync_index,exports.syncEffect=RecoilSync_index_2,exports.urlSyncEffect=RecoilSync_index_6,Object.defineProperty(exports,"__esModule",{value:!0})}));
