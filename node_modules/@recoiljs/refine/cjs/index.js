'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function err(message) {
  const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the
  // err.stack property is accessed.

  if (error.stack === undefined) {
    // IE sets the stack only if error is thrown
    try {
      throw error;
    } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty

  }

  return error;
}

var err_1 = err;

// @oss-only


var Recoil_err = err_1;

/**
 * function to assert that a given value matches a checker
 */


/**
 * helper for raising an error based on a failure
 */
function raiseError(suffix, resultFailure) {
  if (resultFailure != null) {
    const path = resultFailure.path.toString();
    const message = resultFailure.message;
    throw Recoil_err(`[refine.js (path=${path}, message=${message})]: ${suffix}`);
  }

  throw Recoil_err(`[refine.js (null result)]: ${suffix}`);
}
/**
 * create a function to assert a value matches a checker, throwing otherwise
 *
 * For example,
 *
 * ```
 * const assert = assertion(array(number()));
 * const value: Array<number> = assert([1,2]);
 *
 * try {
 *   // should throw with `Refine.js assertion failed: ...`
 *   const invalid = assert('test');
 * } catch {
 * }
 * ```
 */


function assertion(checker, errorMessage = 'assertion error') {
  return value => {
    const result = checker(value);
    return result.type === 'success' ? result.value : raiseError(errorMessage, result);
  };
}
/**
 * create a CoercionFunction given a checker.
 *
 * Allows for null-coercing a value to a given type using a checker. Optionally
 * provide a callback which receives the full check
 * result object (e.g. for logging).
 *
 * Example:
 *
 * ```javascript
 * import {coercion, record, string} from 'refine';
 * import MyLogger from './MyLogger';
 *
 * const Person = record({
 *   name: string(),
 *   hobby: string(),
 * });
 *
 * const coerce = coercion(Person, result => MyLogger.log(result));
 *
 * declare value: mixed;
 *
 * // ?Person
 * const person = coerce(value);
 * ```
 */


function coercion(checker, onResult) {
  return value => {
    const result = checker(value);

    if (onResult != null) {
      onResult(result);
    }

    return result.type === 'success' ? result.value : null;
  };
}

var Refine_API = {
  assertion,
  coercion
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * refine: type-refinement combinator library for checking mixed values
 * see wiki for more info: https://fburl.com/wiki/14q16qqy
 *
 * 
 * @format
 * @oncall monitoring_interfaces
 */

/**
 * the result of successfully matching a value to its expected type
 */

/**
 * the result of checking whether a type matches an expected value
 */

/**
 * a function which checks if a given mixed value matches a type V,
 * returning the value if it does, otherwise a failure message.
 */

/**
 * utility type to extract flowtype matching checker structure
 *
 * ```
 * const check = array(record({a: number()}));
 *
 * // equal to: type MyArray = $ReadOnlyArray<{a: number}>;
 * type MyArray = CheckerReturnType<typeof check>;
 * ```
 */

/**
 * Path during checker traversal
 */
class Path {
  constructor(parent = null, field = '<root>') {
    _defineProperty(this, "parent", void 0);

    _defineProperty(this, "field", void 0);

    this.parent = parent;
    this.field = field;
  } // Method to extend path by a field while traversing a container


  extend(field) {
    return new Path(this, field);
  }

  toString() {
    const pieces = [];
    let current = this;

    while (current != null) {
      const {
        field,
        parent
      } = current;
      pieces.push(field);
      current = parent;
    }

    return pieces.reverse().join('');
  }

}
/**
 * wrap value in an object signifying successful checking
 */


function success(value, warnings) {
  return {
    type: 'success',
    value,
    warnings
  };
}
/**
 * indicate typecheck failed
 */


function failure(message, path) {
  return {
    type: 'failure',
    message,
    path
  };
}
/**
 * utility function for composing checkers
 */


function compose(checker, next) {
  return (value, path = new Path()) => {
    const result = checker(value, path);
    return result.type === 'failure' ? result : next(result, path);
  };
}

var Refine_Checkers = {
  Path,
  success,
  failure,
  compose
};

var Refine_Checkers_1 = Refine_Checkers.Path;
var Refine_Checkers_2 = Refine_Checkers.success;
var Refine_Checkers_3 = Refine_Checkers.failure;
var Refine_Checkers_4 = Refine_Checkers.compose;

var Refine_Checkers$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Path: Refine_Checkers_1,
  success: Refine_Checkers_2,
  failure: Refine_Checkers_3,
  compose: Refine_Checkers_4
});

const {
  Path: Path$1,
  compose: compose$1,
  failure: failure$1,
  success: success$1
} = Refine_Checkers$1; // Check that the provided value is a plain object and not an instance of some
// other container type, built-in, or user class.


function isPlainObject(value) {
  // $FlowIssue[method-unbinding]
  if (Object.prototype.toString.call(value) !== '[object Object]') {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}
/**
 * checker to assert if a mixed value is an array of
 * values determined by a provided checker
 */


function array(valueChecker) {
  return (value, path = new Path$1()) => {
    if (!Array.isArray(value)) {
      return failure$1('value is not an array', path);
    }

    const len = value.length;
    const out = new Array(len);
    const warnings = [];

    for (let i = 0; i < len; i++) {
      const element = value[i];
      const result = valueChecker(element, path.extend(`[${i}]`));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out[i] = result.value;

      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
}
/**
 * checker to assert if a mixed value is a tuple of values
 * determined by provided checkers. Extra entries are ignored.
 *
 * Example:
 * ```jsx
 * const checker = tuple( number(), string() );
 * ```
 *
 * Example with optional trailing entry:
 * ```jsx
 * const checker = tuple( number(), voidable(string()));
 * ```
 */


function tuple(...checkers) {
  return (value, path = new Path$1()) => {
    if (!Array.isArray(value)) {
      return failure$1('value is not an array', path);
    }

    const out = new Array(checkers.length);
    const warnings = [];

    for (const [i, checker] of checkers.entries()) {
      const result = checker(value[i], path.extend(`[${i}]`));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out[i] = result.value;

      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
}
/**
 * checker to assert if a mixed value is a string-keyed dict of
 * values determined by a provided checker
 */


function dict(valueChecker) {
  return (value, path = new Path$1()) => {
    if (typeof value !== 'object' || value === null || !isPlainObject(value)) {
      return failure$1('value is not an object', path);
    }

    const out = {};
    const warnings = [];

    for (const [key, element] of Object.entries(value)) {
      const result = valueChecker(element, path.extend(`.${key}`));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out[key] = result.value;

      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
} // expose opaque version of optional property as public api,
// forcing consistent usage of built-in `optional` to define optional properties


// not a public api, don't export at root
class OptionalProperty {
  constructor(checker) {
    _defineProperty(this, "checker", void 0);

    this.checker = checker;
  }

}
/**
 * checker which can only be used with `object` or `writablObject`. Marks a
 * field as optional, skipping the key in the result if it doesn't
 * exist in the input.
 *
 * @example
 * ```jsx
 * import {object, string, optional} from 'refine';
 *
 * const checker = object({a: string(), b: optional(string())});
 * assert(checker({a: 1}).type === 'success');
 * ```
 */


function optional(checker) {
  return new OptionalProperty((value, path = new Path$1()) => {
    const result = checker(value, path);

    if (result.type === 'failure') {
      return { ...result,
        message: '(optional property) ' + result.message
      };
    } else {
      return result;
    }
  });
}
/**
 * checker to assert if a mixed value is a fixed-property object,
 * with key-value pairs determined by a provided object of checkers.
 * Any extra properties in the input object values are ignored.
 * Class instances are not supported, use the custom() checker for those.
 *
 * Example:
 * ```jsx
 * const myObject = object({
 *   name: string(),
 *   job: object({
 *     years: number(),
 *     title: string(),
 *   }),
 * });
 * ```
 *
 * Properties can be optional using `voidable()` or have default values
 * using `withDefault()`:
 * ```jsx
 * const customer = object({
 *   name: string(),
 *   reference: voidable(string()),
 *   method: withDefault(string(), 'email'),
 * });
 * ```
 */


function object(checkers) {
  const checkerProperties = Object.keys(checkers);
  return (value, path = new Path$1()) => {
    if (typeof value !== 'object' || value === null || !isPlainObject(value)) {
      return failure$1('value is not an object', path);
    }

    const out = {};
    const warnings = [];

    for (const key of checkerProperties) {
      const provided = checkers[key];
      let check;
      let element;

      if (provided instanceof OptionalProperty) {
        check = provided.checker;

        if (!value.hasOwnProperty(key)) {
          continue;
        }

        element = value[key];
      } else {
        check = provided;
        element = value.hasOwnProperty(key) ? value[key] : undefined;
      }

      const result = check(element, path.extend(`.${key}`));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out[key] = result.value;

      if (result.warnings.length !== 0) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
}
/**
 * checker to assert if a mixed value is a Set type
 */


function set(checker) {
  return (value, path = new Path$1()) => {
    if (!(value instanceof Set)) {
      return failure$1('value is not a Set', path);
    }

    const out = new Set();
    const warnings = [];

    for (const item of value) {
      const result = checker(item, path.extend('[]'));

      if (result.type === 'failure') {
        return failure$1(result.message, result.path);
      }

      out.add(result.value);

      if (result.warnings.length) {
        warnings.push(...result.warnings);
      }
    }

    return success$1(out, warnings);
  };
}
/**
 * checker to assert if a mixed value is a Map.
 */


function map(keyChecker, valueChecker) {
  return (value, path = new Path$1()) => {
    if (!(value instanceof Map)) {
      return failure$1('value is not a Map', path);
    }

    const out = new Map();
    const warnings = [];

    for (const [k, v] of value.entries()) {
      const keyResult = keyChecker(k, path.extend(`[${k}] key`));

      if (keyResult.type === 'failure') {
        return failure$1(keyResult.message, keyResult.path);
      }

      const valueResult = valueChecker(v, path.extend(`[${k}]`));

      if (valueResult.type === 'failure') {
        return failure$1(valueResult.message, valueResult.path);
      }

      out.set(k, v);
      warnings.push(...keyResult.warnings, ...valueResult.warnings);
    }

    return success$1(out, warnings);
  };
}
/**
 * identical to `array()` except the resulting value is a writable flow type.
 */


function writableArray(valueChecker) {
  return compose$1(array(valueChecker), ({
    value,
    warnings
  }) => success$1([...value], warnings));
}
/**
 * identical to `dict()` except the resulting value is a writable flow type.
 */


function writableDict(valueChecker) {
  return compose$1(dict(valueChecker), ({
    value,
    warnings
  }) => success$1({ ...value
  }, warnings));
}
/**
 * identical to `object()` except the resulting value is a writable flow type.
 */


function writableObject(checkers) {
  return compose$1(object(checkers), ({
    value,
    warnings
  }) => success$1({ ...value
  }, warnings));
}

var Refine_ContainerCheckers = {
  array,
  tuple,
  object,
  optional,
  dict,
  set,
  map,
  writableArray,
  writableDict,
  writableObject
};

var Refine_ContainerCheckers_1 = Refine_ContainerCheckers.array;
var Refine_ContainerCheckers_2 = Refine_ContainerCheckers.tuple;
var Refine_ContainerCheckers_3 = Refine_ContainerCheckers.object;
var Refine_ContainerCheckers_4 = Refine_ContainerCheckers.optional;
var Refine_ContainerCheckers_5 = Refine_ContainerCheckers.dict;
var Refine_ContainerCheckers_6 = Refine_ContainerCheckers.set;
var Refine_ContainerCheckers_7 = Refine_ContainerCheckers.map;
var Refine_ContainerCheckers_8 = Refine_ContainerCheckers.writableArray;
var Refine_ContainerCheckers_9 = Refine_ContainerCheckers.writableDict;
var Refine_ContainerCheckers_10 = Refine_ContainerCheckers.writableObject;

var Refine_ContainerCheckers$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  array: Refine_ContainerCheckers_1,
  tuple: Refine_ContainerCheckers_2,
  object: Refine_ContainerCheckers_3,
  optional: Refine_ContainerCheckers_4,
  dict: Refine_ContainerCheckers_5,
  set: Refine_ContainerCheckers_6,
  map: Refine_ContainerCheckers_7,
  writableArray: Refine_ContainerCheckers_8,
  writableDict: Refine_ContainerCheckers_9,
  writableObject: Refine_ContainerCheckers_10
});

const {
  assertion: assertion$1
} = Refine_API;
/**
 * function which takes a json string, parses it,
 * and matches it with a checker (returning null if no match)
 */


/**
 * @param text A valid JSON string or null.
 * @param reviver A function that transforms the results. This function is called for each member of the object.
 * If a member contains nested objects, the nested objects are transformed before the parent object is.
 */
function tryParseJSONMixed(text, reviver) {
  if (text == null) {
    return null;
  }

  try {
    return JSON.parse(text, reviver);
  } catch {
    return null;
  }
}
/**
 * creates a JSON parser which will error if the resulting value is invalid
 */


function jsonParserEnforced(checker, suffix) {
  const assertedChecker = assertion$1(checker, suffix !== null && suffix !== void 0 ? suffix : 'value is invalid');
  return rawJSON => {
    return assertedChecker(tryParseJSONMixed(rawJSON !== null && rawJSON !== void 0 ? rawJSON : ''));
  };
}
/**
 * convienience function to wrap a checker in a function
 * for easy JSON string parsing.
 */


function jsonParser(checker) {
  return rawJSON => {
    const result = checker(tryParseJSONMixed(rawJSON));
    return result.type === 'success' ? result.value : null;
  };
}

var Refine_JSON = {
  jsonParserEnforced,
  jsonParser
};

const {
  Path: Path$2,
  compose: compose$2,
  failure: failure$2,
  success: success$2
} = Refine_Checkers$1;
/**
 * a mixed (i.e. untyped) value
 */


function mixed() {
  return MIXED_CHECKER;
}

const MIXED_CHECKER = value => success$2(value, []);
/**
 * checker to assert if a mixed value matches a literal value
 */


function literal(literalValue) {
  const str = value => JSON.stringify(value);

  return (value, path = new Path$2()) => {
    var _str;

    return value === literalValue ? success$2(literalValue, []) : failure$2(`value is not literal ${(_str = str(literalValue)) !== null && _str !== void 0 ? _str : 'void'}`, path);
  };
}
/**
 * boolean value checker
 */


function bool() {
  // NOTE boolean is a reserved word so boolean() will not export properly in OSS
  return (value, path = new Path$2()) => typeof value === 'boolean' ? success$2(value, []) : failure$2('value is not a boolean', path);
}
/**
 * checker to assert if a mixed value is a number
 */


function number() {
  return (value, path = new Path$2()) => typeof value === 'number' ? success$2(value, []) : failure$2('value is not a number', path);
}
/**
 * Checker to assert if a mixed value is a string.
 *
 * Provide an optional RegExp template to match string against.
 */


function string(regex) {
  return (value, path = new Path$2()) => {
    if (typeof value !== 'string') {
      return failure$2('value is not a string', path);
    }

    if (regex != null && !regex.test(value)) {
      return failure$2(`value does not match regex: ${regex.toString()}`, path);
    }

    return success$2(value, []);
  };
}
/**
 * Checker to assert if a mixed value matches a union of string literals.
 * Legal values are provided as key/values in an object and may be translated by
 * providing different values in the object.
 *
 * For example:
 * ```jsx
 * const suitChecker = stringLiterals({
 *   heart: 'heart',
 *   spade: 'spade',
 *   club: 'club',
 *   diamond: 'diamond',
 * });
 *
 * const suit: 'heart' | 'spade' | 'club' | 'diamond' = assertion(suitChecker())(x);
 * ```
 *
 * Strings can also be mapped to new values:
 * ```jsx
 * const placeholderChecker = stringLiterals({
 *   foo: 'spam',
 *   bar: 'eggs',
 * });
 * ```
 *
 * It can be useful to have a single source of truth for your literals.  To
 * only specify them once and use it for both the Flow union type and the
 * runtime checker you can use the following pattern:
 * ```jsx
 * const suits = {
 *   heart: 'heart',
 *   spade: 'spade',
 *   club: 'club',
 *   diamond: 'diamond',
 * };
 * type Suit = $Values<typeof suits>;
 * const suitChecker = stringLiterls(suits);
 * ```
 */


function stringLiterals(enumValues) {
  return (value, path = new Path$2()) => {
    if (typeof value !== 'string') {
      return failure$2('value must be a string', path);
    }

    const out = enumValues[value];

    if (out == null) {
      return failure$2(`value is not one of ${Object.values(enumValues).join(', ')}`, path);
    }

    return success$2(out, []);
  };
}
/**
 * checker to assert if a mixed value is a Date object
 *
 * For example:
 * ```jsx
 * const dateChecker = date();
 *
 * assertion(dateChecker())(new Date());
 * ```
 */


function date() {
  return (value, path = new Path$2()) => {
    if (!(value instanceof Date)) {
      return failure$2('value is not a date', path);
    }

    if (isNaN(value)) {
      return failure$2('invalid date', path);
    }

    return success$2(value, []);
  };
}
/**
 * checker to coerce a date string to a Date object.  This is useful for input
 * that was from a JSON encoded `Date` object.
 *
 * For example:
 * ```jsx
 * const jsonDateChecker = coerce(jsonDate({encoding: 'string'}));
 *
 * jsonDateChecker('October 26, 1985');
 * jsonDateChecker('1955-11-05T07:00:00.000Z');
 * jsonDateChecker(JSON.stringify(new Date()));
 * ```
 */


function jsonDate() {
  return compose$2(string(), ({
    value,
    warnings
  }, path) => {
    const parsedDate = new Date(value);
    return Number.isNaN(parsedDate) ? failure$2('value is not valid date string', path) : success$2(parsedDate, warnings);
  });
}

var Refine_PrimitiveCheckers = {
  mixed,
  literal,
  bool,
  number,
  string,
  stringLiterals,
  date,
  jsonDate
};

const {
  Path: Path$3,
  compose: compose$3,
  failure: failure$3,
  success: success$3
} = Refine_Checkers$1;
/**
 * Cast the type of a value after passing a given checker
 *
 * For example:
 *
 * ```javascript
 * import {string, asType} from 'refine';
 *
 * opaque type ID = string;
 *
 * const IDChecker: Checker<ID> = asType(string(), s => (s: ID));
 * ```
 */


function asType(checker, cast) {
  return compose$3(checker, ({
    value,
    warnings
  }) => success$3(cast(value), warnings));
}

function unionFailure(message, path, failures) {
  return failure$3(`${message}: ${failures.map(f => f.message).join(', ')}`, path);
}
/**
 * checker which asserts the value matches
 * at least one of the two provided checkers
 */


function or(aChecker, bChecker) {
  return (value, path = new Path$3()) => {
    const a = aChecker(value, path);

    if (a.type === 'success') {
      return success$3(a.value, a.warnings);
    }

    const b = bChecker(value, path);

    if (b.type === 'success') {
      return success$3(b.value, b.warnings);
    }

    return unionFailure('value did not match any types in or()', path, [a, b]);
  };
}
/**
 * checker which asserts the value matches
 * at least one of the provided checkers
 *
 * NOTE: the reason `union` and `or` both exist is that there is a bug
 *       within flow that prevents extracting the type from `union` without
 *       annotation -- see https://fburl.com/gz7u6401
 */


function union(...checkers) {
  return (value, path = new Path$3()) => {
    const failures = [];

    for (const checker of checkers) {
      const result = checker(value, path);

      if (result.type === 'success') {
        return success$3(result.value, result.warnings);
      }

      failures.push(result);
    }

    return unionFailure('value did not match any types in union', path, failures);
  };
}
/**
 * Provide a set of checkers to check in sequence to use the first match.
 * This is similar to union(), but all checkers must have the same type.
 *
 * This can be helpful for supporting backward compatibility.  For example the
 * following loads a string type, but can also convert from a number as the
 * previous version or pull from an object as an even older version:
 *
 * ```jsx
 * const backwardCompatibilityChecker: Checker<string> = match(
 *   string(),
 *   asType(number(), num => `${num}`),
 *   asType(object({num: number()}), obj => `${obj.num}`),
 * );
 * ```
 */


function match(...checkers) {
  return union(...checkers);
}
/**
 * wraps a given checker, making the valid value nullable
 *
 * By default, a value passed to nullable must match the checker spec exactly
 * when it is not null, or it will fail.
 *
 * passing the `nullWithWarningWhenInvalid` enables gracefully handling invalid
 * values that are less important -- if the provided checker is invalid,
 * the new checker will return null.
 *
 * For example:
 *
 * ```javascript
 * import {nullable, record, string} from 'refine';
 *
 * const Options = object({
 *   // this must be a non-null string,
 *   // or Options is not valid
 *   filename: string(),
 *
 *   // if this field is not a string,
 *   // it will be null and Options will pass the checker
 *   description: nullable(string(), {
 *     nullWithWarningWhenInvalid: true,
 *   })
 * })
 *
 * const result = Options({filename: 'test', description: 1});
 *
 * invariant(result.type === 'success');
 * invariant(result.value.description === null);
 * invariant(result.warnings.length === 1); // there will be a warning
 * ```
 */


function nullable(checker, options) {
  const {
    nullWithWarningWhenInvalid = false
  } = options !== null && options !== void 0 ? options : {};
  return (value, parentPath = new Path$3()) => {
    if (value == null) {
      return success$3(value, []);
    }

    const result = checker(value, parentPath);

    if (result.type === 'success') {
      return success$3(result.value, result.warnings);
    } // if this is enabled, "succeed" the checker with a warning
    // if the non-null value does not match expectation


    if (nullWithWarningWhenInvalid) {
      return success$3(null, [result]);
    }

    const {
      message,
      path
    } = result;
    return failure$3(message, path);
  };
}
/**
 * wraps a given checker, making the valid value voidable
 *
 * By default, a value passed to voidable must match the checker spec exactly
 * when it is not undefined, or it will fail.
 *
 * passing the `undefinedWithWarningWhenInvalid` enables gracefully handling invalid
 * values that are less important -- if the provided checker is invalid,
 * the new checker will return undefined.
 *
 * For example:
 *
 * ```javascript
 * import {voidable, record, string} from 'refine';
 *
 * const Options = object({
 *   // this must be a string, or Options is not valid
 *   filename: string(),
 *
 *   // this must be a string or undefined,
 *   // or Options is not valid
 *   displayName: voidable(string()),
 *
 *   // if this field is not a string,
 *   // it will be undefined and Options will pass the checker
 *   description: voidable(string(), {
 *     undefinedWithWarningWhenInvalid: true,
 *   })
 * })
 *
 * const result = Options({filename: 'test', description: 1});
 *
 * invariant(result.type === 'success');
 * invariant(result.value.description === undefined);
 * invariant(result.warnings.length === 1); // there will be a warning
 * ```
 */


function voidable(checker, options) {
  const {
    undefinedWithWarningWhenInvalid = false
  } = options !== null && options !== void 0 ? options : {};
  return (value, parentPath = new Path$3()) => {
    if (value === undefined) {
      return success$3(undefined, []);
    }

    const result = checker(value, parentPath);

    if (result.type === 'success') {
      return success$3(result.value, result.warnings);
    } // if this is enabled, "succeed" the checker with a warning
    // if the non-void value does not match expectation


    if (undefinedWithWarningWhenInvalid) {
      return success$3(undefined, [result]);
    }

    const {
      message,
      path
    } = result;
    return failure$3(message, path);
  };
}
/**
 * a checker that provides a withDefault value if the provided value is nullable.
 *
 * For example:
 * ```jsx
 * const objPropertyWithDefault = object({
 *   foo: withDefault(number(), 123),
 * });
 * ```
 * Both `{}` and `{num: 123}` will refine to `{num: 123}`
 */


function withDefault(checker, fallback) {
  return (value, path = new Path$3()) => {
    if (value == null) {
      return success$3(fallback, []);
    }

    const result = checker(value, path);
    return result.type === 'failure' || result.value != null ? result : success$3(fallback, []);
  };
}
/**
 * wraps a checker with a logical constraint.
 *
 * Predicate function can return either a boolean result or
 * a tuple with a result and message
 *
 * For example:
 *
 * ```javascript
 * import {number, constraint} from 'refine';
 *
 * const evenNumber = constraint(
 *   number(),
 *   n => n % 2 === 0
 * );
 *
 * const passes = evenNumber(2);
 * // passes.type === 'success';
 *
 * const fails = evenNumber(1);
 * // fails.type === 'failure';
 * ```
 */


function constraint(checker, predicate) {
  return compose$3(checker, ({
    value,
    warnings
  }, path) => {
    const result = predicate(value);
    const [passed, message] = typeof result === 'boolean' ? [result, 'value failed constraint check'] : result;
    return passed ? success$3(value, warnings) : failure$3(message, path);
  });
}
/**
 * wrapper to allow for passing a lazy checker value. This enables
 * recursive types by allowing for passing in the returned value of
 * another checker. For example:
 *
 * ```javascript
 * const user = object({
 *   id: number(),
 *   name: string(),
 *   friends: array(lazy(() => user))
 * });
 * ```
 *
 * Example of array with arbitrary nesting depth:
 * ```jsx
 * const entry = or(number(), array(lazy(() => entry)));
 * const nestedArray = array(entry);
 * ```
 */


function lazy(getChecker) {
  return (value, path = new Path$3()) => {
    const checker = getChecker();
    return checker(value, path);
  };
}
/**
 * helper to create a custom checker from a provided function.
 * If the function returns a non-nullable value, the checker succeeds.
 *
 * ```jsx
 * const myClassChecker = custom(x => x instanceof MyClass ? x : null);
 * ```
 *
 * Nullable custom types can be created by composing with `nullable()` or
 * `voidable()` checkers:
 *
 * ```jsx
 * const maybeMyClassChecker =
 *   nullable(custom(x => x instanceof MyClass ? x : null));
 * ```
 */


function custom(checkValue, failureMessage = `failed to return non-null from custom checker.`) {
  return (value, path = new Path$3()) => {
    try {
      const checked = checkValue(value);
      return checked != null ? success$3(checked, []) : failure$3(failureMessage, path);
    } catch (error) {
      return failure$3(error.message, path);
    }
  };
}

var Refine_UtilityCheckers = {
  or,
  union,
  match,
  nullable,
  voidable,
  withDefault,
  constraint,
  asType,
  lazy,
  custom
};

const {
  assertion: assertion$2,
  coercion: coercion$1
} = Refine_API;

const {
  Path: Path$4
} = Refine_Checkers$1;

const {
  array: array$1,
  dict: dict$1,
  map: map$1,
  object: object$1,
  optional: optional$1,
  set: set$1,
  tuple: tuple$1,
  writableArray: writableArray$1,
  writableDict: writableDict$1,
  writableObject: writableObject$1
} = Refine_ContainerCheckers$1;

const {
  jsonParser: jsonParser$1,
  jsonParserEnforced: jsonParserEnforced$1
} = Refine_JSON;

const {
  bool: bool$1,
  date: date$1,
  jsonDate: jsonDate$1,
  literal: literal$1,
  mixed: mixed$1,
  number: number$1,
  string: string$1,
  stringLiterals: stringLiterals$1
} = Refine_PrimitiveCheckers;

const {
  asType: asType$1,
  constraint: constraint$1,
  custom: custom$1,
  lazy: lazy$1,
  match: match$1,
  nullable: nullable$1,
  or: or$1,
  union: union$1,
  voidable: voidable$1,
  withDefault: withDefault$1
} = Refine_UtilityCheckers;

var Refine_index = {
  // API
  assertion: assertion$2,
  coercion: coercion$1,
  jsonParser: jsonParser$1,
  jsonParserEnforced: jsonParserEnforced$1,
  Path: Path$4,
  // Checkers - Primitives
  mixed: mixed$1,
  literal: literal$1,
  bool: bool$1,
  number: number$1,
  string: string$1,
  stringLiterals: stringLiterals$1,
  date: date$1,
  jsonDate: jsonDate$1,
  // Checkers - Utility
  asType: asType$1,
  or: or$1,
  union: union$1,
  match: match$1,
  nullable: nullable$1,
  voidable: voidable$1,
  withDefault: withDefault$1,
  constraint: constraint$1,
  lazy: lazy$1,
  custom: custom$1,
  // Checkers - Containers
  array: array$1,
  tuple: tuple$1,
  dict: dict$1,
  object: object$1,
  optional: optional$1,
  set: set$1,
  map: map$1,
  writableArray: writableArray$1,
  writableDict: writableDict$1,
  writableObject: writableObject$1
};
var Refine_index_1 = Refine_index.assertion;
var Refine_index_2 = Refine_index.coercion;
var Refine_index_3 = Refine_index.jsonParser;
var Refine_index_4 = Refine_index.jsonParserEnforced;
var Refine_index_5 = Refine_index.Path;
var Refine_index_6 = Refine_index.mixed;
var Refine_index_7 = Refine_index.literal;
var Refine_index_8 = Refine_index.bool;
var Refine_index_9 = Refine_index.number;
var Refine_index_10 = Refine_index.string;
var Refine_index_11 = Refine_index.stringLiterals;
var Refine_index_12 = Refine_index.date;
var Refine_index_13 = Refine_index.jsonDate;
var Refine_index_14 = Refine_index.asType;
var Refine_index_15 = Refine_index.or;
var Refine_index_16 = Refine_index.union;
var Refine_index_17 = Refine_index.match;
var Refine_index_18 = Refine_index.nullable;
var Refine_index_19 = Refine_index.voidable;
var Refine_index_20 = Refine_index.withDefault;
var Refine_index_21 = Refine_index.constraint;
var Refine_index_22 = Refine_index.lazy;
var Refine_index_23 = Refine_index.custom;
var Refine_index_24 = Refine_index.array;
var Refine_index_25 = Refine_index.tuple;
var Refine_index_26 = Refine_index.dict;
var Refine_index_27 = Refine_index.object;
var Refine_index_28 = Refine_index.optional;
var Refine_index_29 = Refine_index.set;
var Refine_index_30 = Refine_index.map;
var Refine_index_31 = Refine_index.writableArray;
var Refine_index_32 = Refine_index.writableDict;
var Refine_index_33 = Refine_index.writableObject;

exports.Path = Refine_index_5;
exports.array = Refine_index_24;
exports.asType = Refine_index_14;
exports.assertion = Refine_index_1;
exports.bool = Refine_index_8;
exports.coercion = Refine_index_2;
exports.constraint = Refine_index_21;
exports.custom = Refine_index_23;
exports.date = Refine_index_12;
exports.default = Refine_index;
exports.dict = Refine_index_26;
exports.jsonDate = Refine_index_13;
exports.jsonParser = Refine_index_3;
exports.jsonParserEnforced = Refine_index_4;
exports.lazy = Refine_index_22;
exports.literal = Refine_index_7;
exports.map = Refine_index_30;
exports.match = Refine_index_17;
exports.mixed = Refine_index_6;
exports.nullable = Refine_index_18;
exports.number = Refine_index_9;
exports.object = Refine_index_27;
exports.optional = Refine_index_28;
exports.or = Refine_index_15;
exports.set = Refine_index_29;
exports.string = Refine_index_10;
exports.stringLiterals = Refine_index_11;
exports.tuple = Refine_index_25;
exports.union = Refine_index_16;
exports.voidable = Refine_index_19;
exports.withDefault = Refine_index_20;
exports.writableArray = Refine_index_31;
exports.writableDict = Refine_index_32;
exports.writableObject = Refine_index_33;
